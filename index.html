<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Social Medium CRM V3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- React and Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Firebase SDKs (Compat Version) -->
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore-compat.js"></script>
    <script>
        // --- Firebase Configuration ---
        // This is a placeholder configuration. Replace with your actual Firebase project details.
        const firebaseConfig = {
            apiKey: "AIzaSyCImFoyVJdVcRS-c7MXADhTQL7BGa20hHg",
            authDomain: "social-medium-crm.firebaseapp.com",
            projectId: "social-medium-crm",
            storageBucket: "social-medium-crm.appspot.com",
            messagingSenderId: "96565037485",
            appId: "1:96565037485:web:a7bb8427e2aae212b0b924",
            measurementId: "G-K3RE8VJE4S"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #root { height: 100vh; }
        .spinner { border: 2px solid rgba(0, 0, 0, 0.1); width: 20px; height: 20px; border-radius: 50%; border-left-color: #06b6d4; animation: spin 1s ease infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body class="bg-gray-100">

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback, useRef } = React;

        // --- Utility Functions ---
        const formatSimpleDate = (dateString) => {
            if (!dateString || dateString === 'N/A') return 'N/A';
            const date = new Date(dateString);
            if (isNaN(date)) return 'N/A';
            return date.toLocaleDateString();
        };

        const formatDetailedDate = (dateString) => {
            if (!dateString) return 'N/A';
            const date = new Date(dateString);
            if (isNaN(date)) return 'N/A';
            return date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric', hour: 'numeric', minute: 'numeric' });
        };

        const getNestedValue = (obj, path) => {
            if (!path) return undefined;
            return path.reduce((acc, part) => acc && acc[part], obj);
        }
        
        const getRelativeDateRange = (period) => {
            const now = new Date();
            let start = new Date();
            let end = new Date();

            switch (period) {
                case 'yesterday':
                    start.setDate(now.getDate() - 1);
                    end.setDate(now.getDate() - 1);
                    break;
                case 'lastWeek':
                    start.setDate(now.getDate() - now.getDay() - 6);
                    end.setDate(now.getDate() - now.getDay());
                    break;
                case 'lastMonth':
                    start = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                    end = new Date(now.getFullYear(), now.getMonth(), 0);
                    break;
                case 'lastQuarter':
                    const quarter = Math.floor(now.getMonth() / 3);
                    start = new Date(now.getFullYear(), quarter * 3 - 3, 1);
                    end = new Date(now.getFullYear(), quarter * 3, 0);
                    break;
                case 'lastYear':
                    start = new Date(now.getFullYear() - 1, 0, 1);
                    end = new Date(now.getFullYear() - 1, 11, 31);
                    break;
                default:
                    return { start: '', end: '' };
            }
            
            start.setHours(0, 0, 0, 0);
            end.setHours(23, 59, 59, 999);

            return {
                start: start.toISOString().split('T')[0],
                end: end.toISOString().split('T')[0]
            };
        };


        // --- Main App Component ---
        function App() {
            const [user, setUser] = useState(null);
            const [authLoading, setAuthLoading] = useState(true);
            const [squareAccessToken, setSquareAccessToken] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [loadingMessage, setLoadingMessage] = useState('');
            const [error, setError] = useState('');
            
            // Data stores
            const [allCustomers, setAllCustomers] = useState([]);
            const [groupsMap, setGroupsMap] = useState(new Map());
            const [segmentsMap, setSegmentsMap] = useState(new Map());
            const [customAttrDefs, setCustomAttrDefs] = useState(new Map());
            const [catalogItems, setCatalogItems] = useState([]);
            const [locationId, setLocationId] = useState(null);
            const [personalReports, setPersonalReports] = useState([]);
            const [publicReports, setPublicReports] = useState([]);
            
            // View management
            const [currentView, setCurrentView] = useState('dashboard');
            const [reportToLoad, setReportToLoad] = useState(null);
            const [selectedCustomer, setSelectedCustomer] = useState(null);
            const [customerDetails, setCustomerDetails] = useState(null);

            const API_PROXY_URL = 'https://square-checkin-backend.onrender.com';

            const apiFetch = async (endpoint, options = {}) => {
                const response = await fetch(`${API_PROXY_URL}/api${endpoint}`, {
                    ...options,
                    headers: { ...options.headers, 'x-square-access-token': squareAccessToken, 'Content-Type': 'application/json' },
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.errors?.[0]?.detail || data.error || 'An API error occurred.');
                return data;
            };
            
            useEffect(() => {
                const unsubscribe = auth.onAuthStateChanged(user => {
                    setUser(user);
                    setAuthLoading(false);
                });
                return () => unsubscribe();
            }, []);

            useEffect(() => {
                if (user) {
                    const userDocRef = db.collection('users').doc(user.uid);
                    const publicReportsDocRef = db.collection('public').doc('reports');
                    
                    const deserializeReports = (reports = []) => {
                        return reports.map(report => ({
                            ...report,
                            filters: Object.entries(report.filters || {}).reduce((acc, [key, val]) => {
                                acc[key] = { ...val, values: new Set(val.values || []) };
                                return acc;
                            }, {}),
                            purchaseFilters: report.purchaseFilters || []
                        }));
                    };

                    const unsubscribeUser = userDocRef.onSnapshot((doc) => {
                        if (doc.exists) {
                            const data = doc.data();
                            setSquareAccessToken(data.squareAccessToken || null);
                            setPersonalReports(deserializeReports(data.savedReports));
                        } else {
                            userDocRef.set({ squareAccessToken: null, savedReports: [] });
                        }
                    });

                    const unsubscribePublic = publicReportsDocRef.onSnapshot((doc) => {
                        if (doc.exists) {
                            setPublicReports(deserializeReports(doc.data().allReports));
                        }
                    });

                    return () => {
                        unsubscribeUser();
                        unsubscribePublic();
                    };
                }
            }, [user]);

            useEffect(() => {
                if (squareAccessToken) {
                    const fetchInitialData = async () => {
                        setIsLoading(true);
                        setLoadingMessage('Fetching initial data...');
                        setError('');
                        try {
                            const [groupsData, segmentsData, locationData, customAttrData, catalogData] = await Promise.all([
                                apiFetch('/v2/customers/groups'),
                                apiFetch('/v2/customers/segments'),
                                apiFetch('/v2/locations'),
                                apiFetch('/v2/customers/custom-attribute-definitions'),
                                apiFetch('/v2/catalog/search', { method: 'POST', body: JSON.stringify({ object_types: ["ITEM"] }) })
                            ]);

                            if (groupsData.groups) setGroupsMap(new Map(groupsData.groups.map(g => [g.id, g.name])));
                            if (segmentsData.segments) setSegmentsMap(new Map(segmentsData.segments.map(s => [s.id, s.name])));
                            if (customAttrData.custom_attribute_definitions) {
                                setCustomAttrDefs(new Map(customAttrData.custom_attribute_definitions.map(def => [def.key, def])));
                            }
                            if (catalogData.objects) setCatalogItems(catalogData.objects.sort((a, b) => a.item_data.name.localeCompare(b.item_data.name)));
                            
                            const activeLocation = locationData.locations?.find(loc => loc.status === 'ACTIVE');
                            if (activeLocation) {
                                setLocationId(activeLocation.id);
                            } else {
                                throw new Error("No active location found for this business.");
                            }
                            
                            await fetchAllCustomers();

                        } catch (err) {
                            // FIX: Check for authorization error specifically.
                            if (err.message.toLowerCase().includes('authorized')) {
                                console.error("[AUTH] Invalid token detected. Clearing token and prompting for a new one.");
                                // Clear the bad token from Firestore
                                const userDocRef = db.collection('users').doc(user.uid);
                                await userDocRef.update({ squareAccessToken: null });
                                // Clear the token from state, which will trigger the UI to show the SettingsPage
                                setSquareAccessToken(null);
                                setError(''); // Clear the generic error message
                            } else {
                                // For all other errors, just display them.
                                setError(err.message);
                            }
                        } finally {
                            setIsLoading(false);
                            setLoadingMessage('');
                        }
                    };
                    
                    const fetchAllCustomers = async () => {
                        setLoadingMessage('Fetching all customers...');
                        let fetchedCustomers = [];
                        let cursor = undefined;
                        do {
                            const data = await apiFetch('/v2/customers/search', {
                                method: 'POST',
                                body: JSON.stringify({ query: { sort: { field: "CREATED_AT", order: "DESC" } }, cursor: cursor })
                            });
                            if (data.customers) fetchedCustomers.push(...data.customers);
                            cursor = data.cursor;
                        } while (cursor);
                        
                        fetchedCustomers.sort((a, b) => (a.given_name || '').localeCompare(b.given_name || ''));
                        setAllCustomers(fetchedCustomers);
                    };

                    fetchInitialData();
                }
            }, [squareAccessToken, user]); // Added user to dependency array
            
            const handleSelectCustomer = (customer) => {
                setIsLoading(true);
                setSelectedCustomer(customer);
                setCustomerDetails(null);
                setCurrentView('profile');
                setLoadingMessage('Fetching customer details...');
                setError('');

                const fetchDetails = async () => {
                    if (!locationId) {
                        setError("Location ID is not set. Cannot fetch orders.");
                        setIsLoading(false);
                        return;
                    }

                    try {
                        const [customerData, ordersData] = await Promise.all([
                            apiFetch(`/v2/customers/${customer.id}`),
                            apiFetch('/v2/orders/search', {
                                method: 'POST',
                                body: JSON.stringify({
                                    location_ids: [locationId],
                                    query: {
                                        filter: {
                                            customer_filter: { customer_ids: [customer.id] },
                                            state_filter: { states: ["COMPLETED"] }
                                        },
                                        sort: { sort_field: "CLOSED_AT", sort_order: "DESC" }
                                    },
                                    limit: 1
                                })
                            })
                        ]);
                        
                        setCustomerDetails({ ...customerData.customer, last_visit: ordersData.orders?.[0]?.closed_at });

                    } catch (err) {
                        setError(err.message);
                    } finally {
                        setIsLoading(false);
                        setLoadingMessage('');
                    }
                };
                
                fetchDetails();
            };
            
            const serializeReport = (report) => {
                const serializedFilters = {};
                if (report.filters) {
                    for (const key in report.filters) {
                        const filterConfig = report.filters[key];
                        serializedFilters[key] = {
                            ...filterConfig,
                            values: Array.from(filterConfig.values || [])
                        };
                    }
                }
                const newReport = { ...report, filters: serializedFilters };
                delete newReport.isPersonal;
                return newReport;
            };

            const handleSaveReport = async (report, isWidget, isShared) => {
                const reportWithId = { ...report, id: report.id || crypto.randomUUID(), isWidget };
                const serializedReport = serializeReport(reportWithId);

                if (isShared) {
                    const publicReportsDocRef = db.collection('public').doc('reports');
                    try {
                         await publicReportsDocRef.update({
                            allReports: firebase.firestore.FieldValue.arrayUnion(serializedReport)
                        });
                    } catch (err) {
                        if (err.code === 'not-found') {
                            await publicReportsDocRef.set({ allReports: [serializedReport] });
                        } else {
                           console.error("Error saving shared report:", err);
                           setError("Could not save shared report.");
                        }
                    }
                } else {
                    const userDocRef = db.collection('users').doc(user.uid);
                    await userDocRef.update({
                        savedReports: firebase.firestore.FieldValue.arrayUnion(serializedReport)
                    });
                }
            };
            
            const handleRenameReport = async (reportId, newName, isPersonal) => {
                const updateLogic = (reports) => reports.map(r => r.id === reportId ? { ...r, name: newName } : r);
                
                if (isPersonal) {
                    const updatedReports = updateLogic(personalReports);
                    await db.collection('users').doc(user.uid).update({ savedReports: updatedReports.map(serializeReport) });
                } else {
                    const updatedReports = updateLogic(publicReports);
                    await db.collection('public').doc('reports').set({ allReports: updatedReports.map(serializeReport) });
                }
            };

            const handleDeleteReport = async (reportId, isPersonal) => {
                if (isPersonal) {
                    const userDocRef = db.collection('users').doc(user.uid);
                    const reportToDelete = personalReports.find(r => r.id === reportId);
                    if (reportToDelete) {
                        await userDocRef.update({
                            savedReports: firebase.firestore.FieldValue.arrayRemove(serializeReport(reportToDelete))
                        });
                    }
                } else {
                    const publicReportsDocRef = db.collection('public').doc('reports');
                    const reportToDelete = publicReports.find(r => r.id === reportId);
                    if (reportToDelete) {
                        await publicReportsDocRef.update({
                            allReports: firebase.firestore.FieldValue.arrayRemove(serializeReport(reportToDelete))
                        });
                    }
                }
            };
            
            const handleNavigate = (view, payload = null) => {
                if (view === 'reports' && payload) {
                    setReportToLoad(payload);
                }
                setCurrentView(view);
            };

            const handleSaveToken = async (token) => {
                if (user) {
                    await db.collection('users').doc(user.uid).update({ squareAccessToken: token });
                    setSquareAccessToken(token);
                }
            };
            
            if (authLoading) {
                return <div className="flex justify-center items-center h-full"><div className="spinner"></div></div>;
            }

            if (!user) {
                return <AuthPage />;
            }

            if (!squareAccessToken) {
                return <SettingsPage onSaveToken={handleSaveToken} userEmail={user.email} />;
            }
            
            const combinedReports = [...personalReports.map(r => ({...r, isPersonal: true})), ...publicReports.map(r => ({...r, isPersonal: false}))];
            const widgets = combinedReports.filter(r => r.isWidget);

            const renderMainContent = () => {
                if (isLoading) return <div className="flex justify-center items-center h-full"><div className="spinner"></div><p className="ml-2">{loadingMessage}</p></div>;
                if (error) return <div className="p-4 m-4 bg-red-100 text-red-700 rounded-md text-center">{error}</div>;

                switch(currentView) {
                    case 'profile':
                        return customerDetails ? <CustomerProfile customer={customerDetails} groupsMap={groupsMap} segmentsMap={segmentsMap} customAttrDefs={customAttrDefs} onBack={() => setCurrentView('directory')} /> : <div className="flex justify-center items-center h-full"><div className="spinner"></div></div>;
                    case 'reports':
                        return <ReportsPage allCustomers={allCustomers} groupsMap={groupsMap} segmentsMap={segmentsMap} customAttrDefs={customAttrDefs} onSelectCustomer={handleSelectCustomer} onBack={() => setCurrentView('dashboard')} apiFetch={apiFetch} savedReports={combinedReports} onSaveReport={handleSaveReport} onRenameReport={handleRenameReport} onDeleteReport={handleDeleteReport} catalogItems={catalogItems} locationId={locationId} initialReport={reportToLoad} onInitialReportLoaded={() => setReportToLoad(null)} />;
                    case 'directory':
                        return <DirectoryPage allCustomers={allCustomers} onSelectCustomer={handleSelectCustomer} onBack={() => setCurrentView('dashboard')} />;
                    case 'dashboard':
                    default:
                        return <Dashboard onNavigate={handleNavigate} widgets={widgets} allCustomers={allCustomers} groupsMap={groupsMap} segmentsMap={segmentsMap} onSelectCustomer={handleSelectCustomer} />;
                }
            };

            return (
                <div className="h-screen flex flex-col">
                    <Toolbar onNavigate={handleNavigate} />
                    <main className="flex-1 overflow-y-auto bg-gray-50">
                        {renderMainContent()}
                    </main>
                </div>
            );
        }

        // --- Child Components ---

        function Toolbar({ onNavigate }) {
            const handleRefresh = () => window.location.reload();
            return (
                <header className="bg-white shadow-md p-4 flex justify-between items-center z-20">
                    <h1 className="text-2xl font-bold text-cyan-700">Social Medium CRM</h1>
                    <div className="flex items-center space-x-4">
                        <button onClick={() => onNavigate('dashboard')} className="text-sm font-medium text-gray-600 hover:text-cyan-600">Dashboard</button>
                        <button onClick={handleRefresh} className="text-sm font-medium text-gray-600 hover:text-cyan-600">Refresh</button>
                        <button onClick={() => auth.signOut()} className="px-4 py-2 bg-cyan-600 text-white rounded-md text-sm font-medium hover:bg-cyan-700">Logout</button>
                    </div>
                </header>
            );
        }

        function AuthPage() {
            const [isLogin, setIsLogin] = useState(true);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');

            const handleSubmit = async (e) => {
                e.preventDefault();
                setError('');
                try {
                    if (isLogin) {
                        await auth.signInWithEmailAndPassword(email, password);
                    } else {
                        await auth.createUserWithEmailAndPassword(email, password);
                    }
                } catch (err) {
                    setError(err.message);
                }
            };

            return (
                <div className="flex items-center justify-center h-full">
                    <div className="w-full max-w-md p-8 bg-white rounded-lg shadow-md">
                        <h1 className="text-2xl font-bold text-center">{isLogin ? 'Login' : 'Sign Up'}</h1>
                        <form onSubmit={handleSubmit} className="mt-6 space-y-4">
                            <input type="email" value={email} onChange={e => setEmail(e.target.value)} placeholder="Email" required className="w-full px-4 py-2 border rounded-md" />
                            <input type="password" value={password} onChange={e => setPassword(e.target.value)} placeholder="Password" required className="w-full px-4 py-2 border rounded-md" />
                            <button type="submit" className="w-full px-6 py-2 text-white bg-cyan-600 rounded-md hover:bg-cyan-700">{isLogin ? 'Login' : 'Sign Up'}</button>
                            {error && <p className="text-red-500 text-sm text-center">{error}</p>}
                        </form>
                        
                        <button onClick={() => setIsLogin(!isLogin)} className="mt-4 text-sm text-cyan-600 hover:underline w-full text-center">
                            {isLogin ? 'Need an account? Sign Up' : 'Already have an account? Login'}
                        </button>
                    </div>
                </div>
            );
        }

        function SettingsPage({ onSaveToken, userEmail }) {
            const [token, setToken] = useState('');
            return (
                <div className="flex items-center justify-center h-full">
                    <div className="w-full max-w-md p-8 bg-white rounded-lg shadow-md text-center">
                        <h1 className="text-2xl font-bold text-gray-800">Connect to Square</h1>
                        <p className="text-gray-500 mt-2 mb-6">Welcome, {userEmail}! Please enter your Square Access Token to continue.</p>
                        <div className="flex items-center space-x-3">
                            <input type="password" value={token} onChange={(e) => setToken(e.target.value)} className="flex-grow block w-full px-4 py-2 text-gray-700 bg-white border border-gray-300 rounded-md" placeholder="Square Access Token" />
                            <button onClick={() => onSaveToken(token)} className="px-6 py-2 text-white bg-cyan-600 rounded-md hover:bg-cyan-700">Save</button>
                        </div>
                        <button onClick={() => auth.signOut()} className="mt-8 text-sm text-gray-500 hover:underline">Logout</button>
                    </div>
                </div>
            );
        }

        function Dashboard({ onNavigate, widgets, allCustomers, groupsMap, segmentsMap, onSelectCustomer }) {
            const handleWidgetClick = (widget) => {
                onNavigate('reports', widget);
            };
            return (
                <div className="p-8">
                    <h2 className="text-4xl font-bold text-gray-800">Dashboard</h2>
                    <p className="text-gray-500">Welcome to your Social Medium CRM.</p>
                    
                    <div className="mt-8 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        <button onClick={() => onNavigate('directory')} className="p-6 bg-white rounded-lg shadow hover:bg-cyan-50 text-left transition">
                            <h3 className="text-xl font-semibold text-gray-800">Directory</h3>
                            <p className="text-gray-500 mt-2">Search and view all customers.</p>
                        </button>
                        <button onClick={() => onNavigate('reports')} className="p-6 bg-white rounded-lg shadow hover:bg-cyan-50 text-left transition">
                            <h3 className="text-xl font-semibold text-gray-800">Reports</h3>
                            <p className="text-gray-500 mt-2">Filter customers by purchase history and activity.</p>
                        </button>
                        {widgets.map((widget) => (
                            <DashboardWidget key={widget.id} widget={widget} allCustomers={allCustomers} groupsMap={groupsMap} segmentsMap={segmentsMap} onSelectCustomer={onSelectCustomer} onWidgetClick={handleWidgetClick} />
                        ))}
                    </div>
                </div>
            );
        }

        function DashboardWidget({ widget, allCustomers, groupsMap, segmentsMap, onSelectCustomer, onWidgetClick }) {
             const filteredCustomers = useMemo(() => {
                let customers = [...allCustomers];
                // Note: Widget filtering logic is simplified for performance on the dashboard.
                // It doesn't include purchase history or complex date logic.
                return customers.filter(customer => {
                    return Object.entries(widget.filters || {}).every(([key, filterConfig]) => {
                        if (!filterConfig || !filterConfig.values || filterConfig.values.size === 0) return true;
                        
                        const col = widget.columns.find(c => c.key === key);
                        if (!col || col.isPurchase) return true; 

                        let customerValue;
                        if (col.key === 'groups') {
                             const customerGroups = new Set([...(customer.group_ids || []).map(id => groupsMap.get(id)), ...(customer.segment_ids || []).map(id => segmentsMap.get(id))].filter(Boolean));
                             return Array.from(filterConfig.values).some(v => customerGroups.has(v));
                        } else {
                            customerValue = (getNestedValue(customer, col.path) || 'N/A').toString();
                        }
                        
                        return filterConfig.values.has(customerValue);
                    });
                });
            }, [widget, allCustomers, groupsMap, segmentsMap]);

            return (
                <div className="p-6 bg-white rounded-lg shadow flex flex-col h-full">
                    <div>
                        <button onClick={() => onWidgetClick(widget)} className="w-full text-left">
                            <h3 className="text-xl font-semibold text-gray-800 hover:text-cyan-600">{widget.name}</h3>
                        </button>
                        <span className="text-sm text-gray-500">{filteredCustomers.length} customers</span>
                    </div>
                    <div className="flex-grow mt-2 overflow-y-auto">
                        <ul className="space-y-1">
                            {filteredCustomers.slice(0, 10).map(c => (
                                <li key={c.id}>
                                    <button onClick={() => onSelectCustomer(c)} className="text-sm text-cyan-600 hover:underline">{c.given_name} {c.family_name}</button>
                                </li>
                            ))}
                        </ul>
                    </div>
                    {filteredCustomers.length > 10 && <p className="text-xs text-gray-400 mt-auto pt-2">...and {filteredCustomers.length - 10} more.</p>}
                </div>
            );
        }
        
        function DirectoryPage({ allCustomers, onSelectCustomer, onBack }) {
            const [searchTerm, setSearchTerm] = useState('');
            const filteredCustomers = useMemo(() => {
                const lowercasedTerm = searchTerm.toLowerCase();
                if (!lowercasedTerm) return allCustomers;
                return allCustomers.filter(c => 
                    (c.given_name && c.given_name.toLowerCase().includes(lowercasedTerm)) ||
                    (c.family_name && c.family_name.toLowerCase().includes(lowercasedTerm)) ||
                    (c.email_address && c.email_address.toLowerCase().includes(lowercasedTerm)) ||
                    (c.phone_number && c.phone_number.includes(searchTerm))
                );
            }, [searchTerm, allCustomers]);

            return (
                <div className="p-8">
                    <button onClick={onBack} className="mb-6 text-cyan-600 hover:text-cyan-800"> &larr; Back to Dashboard</button>
                    <h2 className="text-4xl font-bold text-gray-800">Customer Directory</h2>
                    <div className="mt-4">
                        <input type="text" value={searchTerm} onChange={e => setSearchTerm(e.target.value)} placeholder="Filter customers..." className="w-full max-w-lg px-4 py-2 border rounded-md"/>
                    </div>
                    <div className="mt-8 bg-white rounded-lg shadow overflow-hidden">
                        <ul className="divide-y divide-gray-200">
                            {filteredCustomers.map(customer => (
                                <li key={customer.id}>
                                    <button onClick={() => onSelectCustomer(customer)} className="w-full text-left p-4 hover:bg-gray-50">
                                        <p className="font-semibold text-gray-800">{customer.given_name} {customer.family_name}</p>
                                        <p className="text-sm text-gray-500">{customer.email_address || 'No email'}</p>
                                    </button>
                                </li>
                            ))}
                        </ul>
                    </div>
                </div>
            );
        }

        function ReportsPage({ allCustomers, groupsMap, segmentsMap, customAttrDefs, onSelectCustomer, onBack, apiFetch, savedReports, onSaveReport, onRenameReport, onDeleteReport, catalogItems, locationId, initialReport, onInitialReportLoaded }) {
            const getInitialColumns = useCallback(() => {
                const standardColumns = [
                    { key: 'given_name', label: 'First Name', visible: true, path: ['given_name'] },
                    { key: 'family_name', label: 'Last Name', visible: true, path: ['family_name'] },
                    { key: 'email_address', label: 'Email', visible: true, path: ['email_address'] },
                    { key: 'phone_number', label: 'Phone', visible: false, path: ['phone_number'] },
                    { key: 'created_at', label: 'Customer Since', visible: true, path: ['created_at'] },
                    { key: 'groups', label: 'Groups & Segments', visible: true, path: [] },
                ];
                const customColumns = Array.from(customAttrDefs.values()).map(def => ({
                    key: def.key, label: def.name, visible: false, isCustom: true, path: ['custom_attributes', def.key, 'value']
                }));
                return [...standardColumns, ...customColumns];
            }, [customAttrDefs]);

            const [columns, setColumns] = useState(getInitialColumns);
            const [columnFilters, setColumnFilters] = useState({});
            const [purchaseFilters, setPurchaseFilters] = useState([]);
            const [sortConfig, setSortConfig] = useState({ key: 'given_name', direction: 'ascending' });
            const [purchaseDataCache, setPurchaseDataCache] = useState({});
            const [isFetchingData, setIsFetchingData] = useState(false);
            const [activeColumnFilterPopup, setActiveColumnFilterPopup] = useState(null);
            const [reportingPeriod, setReportingPeriod] = useState({ start: '', end: '', relative: 'all' });
            const [isSaveModalOpen, setIsSaveModalOpen] = useState(false);
            
            const visibleColumns = useMemo(() => columns.filter(c => c.visible), [columns]);
            
            const fetchPurchaseData = useCallback(async (itemId, period) => {
                const item = catalogItems.find(i => i.id === itemId);
                if (!item) return;

                const cacheKey = `${itemId}-${period.relative}-${period.start}-${period.end}`;
                
                if(purchaseDataCache[cacheKey]) {
                    return;
                }

                setIsFetchingData(true);
                try {
                    const variationIds = item.item_data.variations.map(v => v.id);
                    
                    const query = {
                        filter: {
                            state_filter: { states: ["COMPLETED"] },
                            line_item_filter: { catalog_object_ids: variationIds }
                        },
                        // THIS IS THE FIX: Always include a sort object when filtering orders.
                        sort: {
                            sort_field: "CLOSED_AT",
                            sort_order: "DESC"
                        }
                    };
                    
                    let currentReportingPeriod = {...period};
                    if(period.relative && period.relative !== 'all' && period.relative !== 'custom') {
                        currentReportingPeriod = getRelativeDateRange(period.relative);
                    }

                    if (currentReportingPeriod.start && currentReportingPeriod.end) {
                        const start = new Date(currentReportingPeriod.start);
                        const end = new Date(currentReportingPeriod.end);
                        end.setHours(23, 59, 59, 999);
                        query.filter.date_time_filter = { closed_at: { start_at: start.toISOString(), end_at: end.toISOString() } };
                    }

                    let allOrders = [];
                    let cursor = undefined;
                    do {
                       const orderSearchData = await apiFetch('/v2/orders/search', {
                           method: 'POST',
                           body: JSON.stringify({ location_ids: [locationId], cursor: cursor, query: query })
                       });
                       if (orderSearchData.orders) allOrders.push(...orderSearchData.orders);
                       cursor = orderSearchData.cursor;
                    } while (cursor);
                    
                    const customerPurchaseData = new Map();
                    allOrders.forEach(order => {
                        if (!order.customer_id) return;
                        const existingData = customerPurchaseData.get(order.customer_id) || { lastDate: '1970-01-01T00:00:00Z', quantity: 0 };
                        let quantity = 0;
                        order.line_items.forEach(lineItem => {
                           if (variationIds.includes(lineItem.catalog_object_id)) {
                               quantity += parseInt(lineItem.quantity, 10);
                           }
                        });
                        const customerData = {
                           lastDate: order.closed_at > existingData.lastDate ? order.closed_at : existingData.lastDate,
                           quantity: existingData.quantity + quantity
                        };
                        customerPurchaseData.set(order.customer_id, customerData);
                    });

                    setPurchaseDataCache(prev => ({ ...prev, [cacheKey]: customerPurchaseData }));
                } catch (err) {
                    console.error("Error fetching purchase data for item " + itemId, err);
                } finally {
                    setIsFetchingData(false);
                }
            }, [apiFetch, locationId, catalogItems, purchaseDataCache]);
            
            useEffect(() => {
                const requiredItemIds = new Set();
                purchaseFilters.forEach(f => requiredItemIds.add(f.itemId));
                columns.forEach(c => {
                    if (c.isPurchase && c.visible) {
                        requiredItemIds.add(c.itemId);
                    }
                });

                requiredItemIds.forEach(itemId => {
                    const cacheKey = `${itemId}-${reportingPeriod.relative}-${reportingPeriod.start}-${reportingPeriod.end}`;
                    if (!purchaseDataCache[cacheKey]) {
                        fetchPurchaseData(itemId, reportingPeriod);
                    }
                });
            }, [purchaseFilters, columns, reportingPeriod, purchaseDataCache, fetchPurchaseData]);
            
            const handleAddOrUpdatePurchaseColumn = (item, displayMode) => {
                const newColumnKey = `${item.id}-${displayMode}`;
                let label = '';
                if (displayMode === 'yesNo') label = `${item.item_data.name} (Purchased)`;
                if (displayMode === 'lastDate') label = `${item.item_data.name} (Last Purchase)`;
                if (displayMode === 'quantity') label = `${item.item_data.name} (Qty)`;
                
                const newColumn = { key: newColumnKey, label, visible: true, isPurchase: true, itemId: item.id, displayMode };

                setColumns(prev => {
                    const otherItemColumnsRemoved = prev.filter(c => !(c.isPurchase && c.itemId === item.id));
                    return [...otherItemColumnsRemoved, newColumn];
                });
            };

            const filteredAndSortedCustomers = useMemo(() => {
                let filtered = [...allCustomers];
                const cacheKeyPrefix = `${reportingPeriod.relative}-${reportingPeriod.start}-${reportingPeriod.end}`;

                // Apply background purchase filters first
                if (purchaseFilters.length > 0) {
                    filtered = filtered.filter(customer => {
                        return purchaseFilters.every(filter => {
                            const cacheKey = `${filter.itemId}-${cacheKeyPrefix}`;
                            const purchaseData = purchaseDataCache[cacheKey];

                            if (!purchaseData) {
                                return false; 
                            }
                            
                            const customerData = purchaseData.get(customer.id);
                            let result;
                            switch (filter.type) {
                                case 'purchased':
                                    result = customerData ? filter.value === 'yes' : filter.value === 'no';
                                    break;
                                case 'quantity':
                                    const quantity = customerData?.quantity || 0;
                                    const filterValue = parseFloat(filter.value);
                                    if (filter.condition === 'greaterThan') result = quantity > filterValue;
                                    else if (filter.condition === 'lessThan') result = quantity < filterValue;
                                    else result = false;
                                    break;
                                default:
                                    result = true;
                            }
                            return result;
                        });
                    });
                }

                // Apply column filters
                filtered = filtered.filter(customer => {
                    return Object.entries(columnFilters).every(([key, filterConfig]) => {
                        if (!filterConfig || !filterConfig.values || filterConfig.values.size === 0) return true;
                        
                        const col = columns.find(c => c.key === key);
                        if (!col) return true;

                        let customerValue;

                        if (col.isPurchase) {
                            const cacheKey = `${col.itemId}-${reportingPeriod.relative}-${reportingPeriod.start}-${reportingPeriod.end}`;
                            const data = purchaseDataCache[cacheKey]?.get(customer.id);
                            
                            if (col.displayMode === 'yesNo') {
                                customerValue = data ? 'Yes' : 'No';
                            } else if (col.displayMode === 'lastDate') {
                                customerValue = data ? formatSimpleDate(data.lastDate) : 'N/A';
                            } else if (col.displayMode === 'quantity') {
                                customerValue = data ? data.quantity : 0;
                            }
                            return filterConfig.values.has(customerValue);
                        } 
                        
                        if (col.key === 'groups') {
                            const groupNames = (customer.group_ids || []).map(id => groupsMap.get(id));
                            const segmentNames = (customer.segment_ids || []).map(id => segmentsMap.get(id));
                            const customerGroups = new Set([...groupNames, ...segmentNames].filter(Boolean));
                            return Array.from(filterConfig.values).some(v => customerGroups.has(v));
                        }

                        // Default case for standard fields
                        customerValue = getNestedValue(customer, col.path);
                        if (col.path && col.path.includes('created_at')) {
                            customerValue = formatSimpleDate(customerValue);
                        }
                        customerValue = (customerValue || 'N/A').toString();

                        return filterConfig.values.has(customerValue);
                    });
                });

                if (sortConfig.key) {
                    filtered.sort((a, b) => {
                        const col = columns.find(c => c.key === sortConfig.key);
                        if (!col) return 0;
                        let aVal, bVal;
                        if (col.isPurchase) {
                            const cacheKey = `${col.itemId}-${cacheKeyPrefix}`;
                            const aData = purchaseDataCache[cacheKey]?.get(a.id);
                            const bData = purchaseDataCache[cacheKey]?.get(b.id);
                            if (col.displayMode === 'quantity') { aVal = aData?.quantity || 0; bVal = bData?.quantity || 0; }
                            else if (col.displayMode === 'lastDate') { aVal = aData?.lastDate || ''; bVal = bData?.lastDate || ''; }
                            else { aVal = aData ? 1 : 0; bVal = bData ? 1 : 0; }
                        } else if (col.key === 'groups') {
                             const aGroups = [...(a.group_ids || []).map(id => groupsMap.get(id)), ...(a.segment_ids || []).map(id => segmentsMap.get(id))].join('');
                             const bGroups = [...(b.group_ids || []).map(id => groupsMap.get(id)), ...(b.segment_ids || []).map(id => segmentsMap.get(id))].join('');
                             aVal = aGroups; bVal = bGroups;
                        } else {
                            aVal = getNestedValue(a, col.path) || ''; 
                            bVal = getNestedValue(b, col.path) || '';
                        }
                        if (typeof aVal === 'string' && typeof bVal === 'string') {
                            return sortConfig.direction === 'ascending' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                        }
                        if (aVal < bVal) return sortConfig.direction === 'ascending' ? -1 : 1;
                        if (aVal > bVal) return sortConfig.direction === 'ascending' ? 1 : -1;
                        return 0;
                    });
                }
                return filtered;
            }, [allCustomers, columnFilters, purchaseFilters, sortConfig, columns, purchaseDataCache, reportingPeriod, groupsMap, segmentsMap]);
            
            const handleModalSave = (name, isWidget, isShared) => {
                const report = { name, filters: columnFilters, purchaseFilters, sortConfig, columns, reportingPeriod, isWidget, isShared };
                onSaveReport(report, isWidget, isShared);
                setIsSaveModalOpen(false);
            };
            
            const handleLoadReport = (report) => {
                setColumnFilters(report.filters || {});
                setPurchaseFilters(report.purchaseFilters || []);
                setSortConfig(report.sortConfig || { key: 'given_name', direction: 'ascending' });
                setColumns(report.columns || getInitialColumns());
                setReportingPeriod(report.reportingPeriod || { start: '', end: '', relative: 'all' });
            };

            useEffect(() => {
                if (initialReport) {
                    handleLoadReport(initialReport);
                    onInitialReportLoaded();
                }
            }, [initialReport, onInitialReportLoaded, getInitialColumns]);

            return (
                <div className="flex h-full">
                    <ReportsSidebar 
                        columns={columns} 
                        setColumns={setColumns}
                        savedReports={savedReports}
                        onLoadReport={handleLoadReport}
                        onSaveReportClick={() => setIsSaveModalOpen(true)}
                        catalogItems={catalogItems}
                        onAddOrUpdatePurchaseColumn={handleAddOrUpdatePurchaseColumn}
                        reportingPeriod={reportingPeriod}
                        setReportingPeriod={setReportingPeriod}
                        onRenameReport={onRenameReport}
                        onDeleteReport={onDeleteReport}
                        purchaseFilters={purchaseFilters}
                        setPurchaseFilters={setPurchaseFilters}
                    />
                    <div className="flex-1 p-8 overflow-y-auto">
                        <div className="flex justify-between items-center mb-6">
                            <button onClick={onBack} className="text-cyan-600 hover:text-cyan-800"> &larr; Back to Dashboard</button>
                            <span className="text-gray-600 font-semibold">{filteredAndSortedCustomers.length} Customers</span>
                        </div>
                        <h2 className="text-4xl font-bold text-gray-800">Customer Report</h2>
                        <div className="mt-8 bg-white rounded-lg shadow overflow-x-auto">
                            <table className="w-full text-sm text-left text-gray-500">
                                <thead className="text-xs text-gray-700 uppercase bg-gray-50">
                                    <tr>{visibleColumns.map(col => <SortableHeader key={col.key} col={col} setSortConfig={setSortConfig} sortConfig={sortConfig} setActiveFilterPopup={setActiveColumnFilterPopup} filters={columnFilters} />)}</tr>
                                </thead>
                                <tbody>
                                    {isFetchingData && <tr><td colSpan={visibleColumns.length} className="text-center p-4"><div className="flex items-center justify-center"><div className="spinner mr-2"></div>Fetching purchase data...</div></td></tr>}
                                    {!isFetchingData && filteredAndSortedCustomers.length === 0 && <tr><td colSpan={visibleColumns.length} className="text-center p-4 text-gray-500">No customers match the current filters.</td></tr>}
                                    {!isFetchingData && filteredAndSortedCustomers.map(customer => (
                                        <tr key={customer.id} className="bg-white border-b hover:bg-gray-50">
                                            {visibleColumns.map(col => {
                                                let cellContent = 'N/A';
                                                if (col.key === 'given_name') {
                                                    cellContent = <button onClick={() => onSelectCustomer(customer)} className="text-cyan-600 hover:underline font-medium whitespace-nowrap">{customer.given_name || ''}</button>;
                                                } else if (col.key === 'family_name') {
                                                    cellContent = customer.family_name || '';
                                                } else if (col.key === 'groups') {
                                                    const groupNames = (customer.group_ids || []).map(id => ({ name: groupsMap.get(id) || id, color: 'bg-gray-100 text-gray-800' }));
                                                    const segmentNames = (customer.segment_ids || []).map(id => ({ name: segmentsMap.get(id) || id, color: 'bg-green-100 text-green-800' }));
                                                    const allPills = [...groupNames, ...segmentNames];
                                                    cellContent = <div className="flex flex-wrap gap-1">{allPills.map((pill, i) => <Pill key={i} text={pill.name} color={pill.color} />)}</div>;
                                                } else if (col.isPurchase) {
                                                    const cacheKey = `${col.itemId}-${reportingPeriod.relative}-${reportingPeriod.start}-${reportingPeriod.end}`;
                                                    const data = purchaseDataCache[cacheKey]?.get(customer.id);
                                                    if (col.displayMode === 'yesNo') cellContent = data ? 'Yes' : 'No';
                                                    else if (col.displayMode === 'lastDate') cellContent = data ? formatSimpleDate(data.lastDate) : 'N/A';
                                                    else if (col.displayMode === 'quantity') cellContent = data ? data.quantity : 0;
                                                } else if (col.path.includes('created_at')) {
                                                    cellContent = formatSimpleDate(getNestedValue(customer, col.path));
                                                } else {
                                                    cellContent = getNestedValue(customer, col.path) || 'N/A';
                                                }
                                                return <td key={col.key} className="px-6 py-4 whitespace-nowrap">{cellContent}</td>;
                                            })}
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </div>
                    {activeColumnFilterPopup && <FilterPopup column={activeColumnFilterPopup} allCustomers={allCustomers} filters={columnFilters} setFilters={setColumnFilters} onClose={() => setActiveColumnFilterPopup(null)} getNestedValue={getNestedValue} groupsMap={groupsMap} segmentsMap={segmentsMap} purchaseDataCache={purchaseDataCache} reportingPeriod={reportingPeriod} />}
                    {isSaveModalOpen && <SaveReportModal onSave={handleModalSave} onCancel={() => setIsSaveModalOpen(false)} />}
                </div>
            );
        }
        
        // --- Standalone Components ---
        
        const SortableHeader = ({ col, setSortConfig, sortConfig, setActiveFilterPopup, filters }) => {
            const isSorted = sortConfig.key === col.key;
            const isFiltered = filters[col.key] && ((filters[col.key].values && filters[col.key].values.size > 0) || (filters[col.key].condition && filters[col.key].condition.type !== 'none'));

            return (
                <th scope="col" className="px-6 py-3">
                    <div className="flex items-center">
                        <button onClick={() => setSortConfig({ key: col.key, direction: sortConfig.key === col.key && sortConfig.direction === 'ascending' ? 'descending' : 'ascending' })} className="uppercase font-bold">
                            {col.label}
                        </button>
                        {isSorted && (sortConfig.direction === 'ascending' ? <span className="ml-1"></span> : <span className="ml-1"></span>)}
                        <button onClick={() => setActiveFilterPopup(col)} className="ml-2 text-gray-400 hover:text-gray-700">
                            <svg className={`w-4 h-4 ${isFiltered ? 'text-cyan-600' : ''}`} fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M3 3a1 1 0 011-1h12a1 1 0 011 1v3a1 1 0 01-.293.707L12 11.414V15a1 1 0 01-.293.707l-2 2A1 1 0 018 17v-5.586L3.293 6.707A1 1 0 013 6V3z" clipRule="evenodd"></path></svg>
                        </button>
                    </div>
                </th>
            );
        };

        function FilterPopup({ column, allCustomers, filters, setFilters, onClose, getNestedValue, groupsMap, segmentsMap, purchaseDataCache, reportingPeriod }) {
            const getFieldValues = () => {
                const values = new Set();
                
                if (column.isPurchase) {
                    const cacheKey = `${column.itemId}-${reportingPeriod.relative}-${reportingPeriod.start}-${reportingPeriod.end}`;
                    const itemPurchaseData = purchaseDataCache[cacheKey];

                    if (column.displayMode === 'yesNo') {
                        values.add('Yes');
                        values.add('No');
                    } else if (itemPurchaseData) {
                        allCustomers.forEach(customer => {
                            const data = itemPurchaseData.get(customer.id);
                            if (column.displayMode === 'quantity') {
                                values.add(data ? data.quantity : 0);
                            } else if (column.displayMode === 'lastDate') {
                                values.add(data ? formatSimpleDate(data.lastDate) : 'N/A');
                            }
                        });
                    }
                } else {
                    allCustomers.forEach(customer => {
                        let value;
                        if (column.key === 'groups') {
                            (customer.group_ids || []).forEach(id => { if(groupsMap.has(id)) values.add(groupsMap.get(id))});
                            (customer.segment_ids || []).forEach(id => { if(segmentsMap.has(id)) values.add(segmentsMap.get(id))});
                        } else {
                            value = getNestedValue(customer, column.path);
                            if (column.path && column.path.includes('created_at')) {
                                value = formatSimpleDate(value);
                            }
                            values.add((value || 'N/A').toString());
                        }
                    });
                }
                
                return Array.from(values).sort((a,b) => String(a).localeCompare(String(b), undefined, {numeric: true}));
            };
            
            const [uniqueValues] = useState(getFieldValues);
            const [checkedValues, setCheckedValues] = useState(filters[column.key]?.values || new Set());
            const [searchTerm, setSearchTerm] = useState('');

            const handleCheck = (value) => {
                const newChecked = new Set(checkedValues);
                if (newChecked.has(value)) newChecked.delete(value);
                else newChecked.add(value);
                setCheckedValues(newChecked);
            };

            const handleSelectAll = () => setCheckedValues(new Set(filteredUniqueValues));
            const handleClear = () => setCheckedValues(new Set());

            const handleApply = () => {
                setFilters(prev => ({ ...prev, [column.key]: { values: checkedValues } }));
                onClose();
            };
            
            const handleRemoveFilter = () => {
                const newFilters = { ...filters };
                delete newFilters[column.key];
                setFilters(newFilters);
                onClose();
            };

            const filteredUniqueValues = useMemo(() => {
                if (!searchTerm) return uniqueValues;
                return uniqueValues.filter(v => String(v).toLowerCase().includes(searchTerm.toLowerCase()));
            }, [searchTerm, uniqueValues]);

            return (
                <div className="fixed inset-0 bg-black bg-opacity-25 flex items-center justify-center z-30" onClick={onClose}>
                    <div className="bg-white rounded-lg shadow-xl p-4 w-full max-w-sm" onClick={e => e.stopPropagation()}>
                        <div className="flex justify-between items-center">
                            <h3 className="font-bold text-lg">Filter by {column.label}</h3>
                            <button onClick={onClose} className="text-gray-400 hover:text-gray-600">&times;</button>
                        </div>
                        
                        <div className="mt-4 border-t pt-4">
                            <h4 className="text-sm font-semibold mb-2">Filter by values</h4>
                            <div className="my-2 flex space-x-2">
                                <button onClick={handleSelectAll} className="text-sm text-cyan-600 hover:underline">Select all visible</button>
                                <button onClick={handleClear} className="text-sm text-cyan-600 hover:underline">Clear</button>
                            </div>
                            <input type="text" value={searchTerm} onChange={e => setSearchTerm(e.target.value)} placeholder="Search values..." className="w-full px-2 py-1 border rounded-md text-sm mb-2"/>
                            <div className="max-h-40 overflow-y-auto border rounded-md p-2 space-y-1">
                                {filteredUniqueValues.map(value => (
                                    <label key={value} className="flex items-center text-sm hover:bg-gray-50 rounded p-1">
                                        <input type="checkbox" checked={checkedValues.has(value)} onChange={() => handleCheck(value)} className="mr-2 h-4 w-4 text-cyan-600 border-gray-300 rounded focus:ring-cyan-500"/>
                                        <span className="truncate">{value}</span>
                                    </label>
                                ))}
                            </div>
                        </div>

                        <div className="mt-4 flex justify-between items-center">
                            <button onClick={handleRemoveFilter} className="px-4 py-2 text-sm text-red-600 hover:text-red-800">Remove Filter</button>
                            <div className="space-x-2">
                                <button onClick={onClose} className="px-4 py-2 bg-gray-200 rounded-md text-sm">Cancel</button>
                                <button onClick={handleApply} className="px-4 py-2 bg-cyan-600 text-white rounded-md text-sm">OK</button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }
        
        function PurchaseFilterModal({ item, onSave, onCancel, existingFilter }) {
            const [filterType, setFilterType] = useState(existingFilter?.type || 'purchased');
            const [filterValue, setFilterValue] = useState(existingFilter?.value || 'yes');
            const [condition, setCondition] = useState(existingFilter?.condition || 'greaterThan');
            const [quantity, setQuantity] = useState(existingFilter?.value || 0);

            const handleSave = () => {
                if (filterType === 'purchased') {
                    onSave({ itemId: item.id, type: 'purchased', value: filterValue });
                } else {
                    onSave({ itemId: item.id, type: 'quantity', condition: condition, value: quantity });
                }
            };

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onClick={onCancel}>
                    <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-md" onClick={e => e.stopPropagation()}>
                        <h3 className="font-bold text-lg">Filter by: {item.item_data.name}</h3>
                        <div className="mt-4 space-y-4">
                            <div>
                                <label className="block text-sm font-medium text-gray-700">Filter Type</label>
                                <select value={filterType} onChange={e => setFilterType(e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-cyan-500 focus:border-cyan-500 sm:text-sm rounded-md">
                                    <option value="purchased">Purchased Status</option>
                                    <option value="quantity">Quantity Purchased</option>
                                </select>
                            </div>
                            {filterType === 'purchased' && (
                                <div>
                                    <label className="block text-sm font-medium text-gray-700">Status</label>
                                    <select value={filterValue} onChange={e => setFilterValue(e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-cyan-500 focus:border-cyan-500 sm:text-sm rounded-md">
                                        <option value="yes">Has Purchased</option>
                                        <option value="no">Has Not Purchased</option>
                                    </select>
                                </div>
                            )}
                            {filterType === 'quantity' && (
                                <div className="space-y-2">
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700">Condition</label>
                                        <select value={condition} onChange={e => setCondition(e.target.value)} className="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-cyan-500 focus:border-cyan-500 sm:text-sm rounded-md">
                                            <option value="greaterThan">Greater than</option>
                                            <option value="lessThan">Less than</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700">Quantity</label>
                                        <input type="number" value={quantity} onChange={e => setQuantity(e.target.value)} className="mt-1 focus:ring-cyan-500 focus:border-cyan-500 block w-full shadow-sm sm:text-sm border-gray-300 rounded-md"/>
                                    </div>
                                </div>
                            )}
                        </div>
                        <div className="mt-6 flex justify-end space-x-2">
                            <button onClick={onCancel} className="px-4 py-2 bg-gray-200 rounded-md">Cancel</button>
                            <button onClick={handleSave} className="px-4 py-2 bg-cyan-600 text-white rounded-md">{existingFilter ? 'Update' : 'Add'} Filter</button>
                        </div>
                    </div>
                </div>
            );
        }

        function ReportsSidebar({ columns, setColumns, savedReports, onLoadReport, onSaveReportClick, catalogItems, onAddOrUpdatePurchaseColumn, reportingPeriod, setReportingPeriod, onRenameReport, onDeleteReport, purchaseFilters, setPurchaseFilters }) {
            const [openSections, setOpenSections] = useState({ period: true, reports: true, columns: true, purchase: true, activeFilters: true, activeColumns: true });
            const [purchaseSearch, setPurchaseSearch] = useState('');
            const [renameModal, setRenameModal] = useState(null);
            const [deleteModal, setDeleteModal] = useState(null);
            const [editingFilter, setEditingFilter] = useState(null); // Can be { filter, index }
            const [activeColumnPopper, setActiveColumnPopper] = useState(null);

            const toggleSection = (section) => setOpenSections(prev => ({...prev, [section]: !prev[section]}));

            const filteredItems = useMemo(() => {
                if (!purchaseSearch) return catalogItems;
                return catalogItems.filter(item => item.item_data.name.toLowerCase().includes(purchaseSearch.toLowerCase()));
            }, [purchaseSearch, catalogItems]);

            const handleColumnToggle = (key) => {
                setColumns(prev => prev.map(c => {
                    if (c.key === key) return { ...c, visible: !c.visible };
                    // Special handling to show/hide 'family_name' with 'given_name'
                    if (key === 'given_name' && c.key === 'family_name') return { ...c, visible: !c.visible };
                    return c;
                }));
            };
            
            const handleRemoveColumn = (keyToRemove) => {
                setColumns(prevColumns =>
                    prevColumns.map(col =>
                        col.key === keyToRemove ? { ...col, visible: false } : col
                    )
                );
            };

            const handleRelativeDateChange = (e) => {
                setReportingPeriod({ relative: e.target.value, start: '', end: '' });
            };

            const handleRename = (newName) => {
                if (newName && renameModal) { onRenameReport(renameModal.id, newName, renameModal.isPersonal); }
                setRenameModal(null);
            };

            const handleDelete = () => {
                if (deleteModal) { onDeleteReport(deleteModal.id, deleteModal.isPersonal); }
                setDeleteModal(null);
            };

            const handleSavePurchaseFilter = (filter) => {
                if (editingFilter && editingFilter.index !== null) {
                    setPurchaseFilters(prev => prev.map((f, i) => i === editingFilter.index ? filter : f));
                } else {
                    setPurchaseFilters(prev => [...prev, filter]);
                }
                setEditingFilter(null);
            };

            const getFilterDescription = (filter) => {
                const item = catalogItems.find(i => i.id === filter.itemId);
                const itemName = item ? item.item_data.name : 'Unknown Item';
                if (filter.type === 'purchased') {
                    return `${itemName}: Purchased is ${filter.value}`;
                }
                if (filter.type === 'quantity') {
                    const conditionText = filter.condition === 'greaterThan' ? '>' : '<';
                    return `${itemName}: Quantity ${conditionText} ${filter.value}`;
                }
                return 'Unknown filter';
            };

            return (
                <>
                <div className="w-80 bg-white border-r border-gray-200 flex flex-col p-4 space-y-2 overflow-y-auto">
                    <h2 className="text-xl font-bold">Report Controls</h2>
                    <div className="space-y-2">
                        <button onClick={onSaveReportClick} className="w-full px-4 py-2 bg-cyan-600 text-white rounded-md shadow-sm hover:bg-cyan-700">Save Report</button>
                    </div>

                    <SidebarSection title="Active Filters" id="activeFilters" isOpen={openSections.activeFilters} onToggle={toggleSection}>
                        {purchaseFilters.length === 0 ? (
                            <p className="text-sm text-gray-500">No active filters.</p>
                        ) : (
                            <ul className="space-y-1">
                                {purchaseFilters.map((filter, index) => (
                                    <li key={index} className="flex items-center justify-between text-sm bg-gray-100 p-1 rounded group">
                                        <span className="truncate">{getFilterDescription(filter)}</span>
                                        <div className="flex items-center">
                                            <button onClick={() => setEditingFilter({ filter, index })} className="p-1 hover:bg-gray-200 rounded text-xs hidden group-hover:block"></button>
                                            <button onClick={() => setPurchaseFilters(prev => prev.filter((_, i) => i !== index))} className="text-red-500 hover:text-red-700 ml-1">&times;</button>
                                        </div>
                                    </li>
                                ))}
                            </ul>
                        )}
                    </SidebarSection>
                    
                    <SidebarSection title="Active Columns" id="activeColumns" isOpen={openSections.activeColumns} onToggle={toggleSection}>
                        {columns.filter(c => c.visible).length === 0 ? (
                            <p className="text-sm text-gray-500">No visible columns.</p>
                        ) : (
                            <ul className="space-y-1">
                                {columns.filter(c => c.visible).map((col) => (
                                    <li key={col.key} className="flex items-center justify-between text-sm bg-gray-100 p-1 rounded group relative">
                                        <span className="truncate">{col.label}</span>
                                        <div className="flex items-center">
                                            {col.isPurchase && (
                                                <button onClick={() => setActiveColumnPopper(activeColumnPopper === col.key ? null : col.key)} className="p-1 hover:bg-gray-200 rounded text-xs hidden group-hover:block"></button>
                                            )}
                                            <button onClick={() => handleRemoveColumn(col.key)} className="text-red-500 hover:text-red-700 ml-1">&times;</button>
                                        </div>
                                        {activeColumnPopper === col.key && col.isPurchase && (
                                            <div className="absolute right-0 top-full mt-1 w-48 bg-white rounded-md shadow-lg z-20 p-2 border">
                                                <button onClick={() => {onAddOrUpdatePurchaseColumn(catalogItems.find(i=>i.id === col.itemId), 'yesNo'); setActiveColumnPopper(null);}} className="block w-full text-left text-sm p-1 hover:bg-gray-100">Purchased (Y/N)</button>
                                                <button onClick={() => {onAddOrUpdatePurchaseColumn(catalogItems.find(i=>i.id === col.itemId), 'lastDate'); setActiveColumnPopper(null);}} className="block w-full text-left text-sm p-1 hover:bg-gray-100">Last Purchase Date</button>
                                                <button onClick={() => {onAddOrUpdatePurchaseColumn(catalogItems.find(i=>i.id === col.itemId), 'quantity'); setActiveColumnPopper(null);}} className="block w-full text-left text-sm p-1 hover:bg-gray-100">Total Quantity</button>
                                            </div>
                                        )}
                                    </li>
                                ))}
                            </ul>
                        )}
                    </SidebarSection>
                    
                    <SidebarSection title="Reporting Period" id="period" isOpen={openSections.period} onToggle={toggleSection}>
                        <select onChange={handleRelativeDateChange} value={reportingPeriod.relative} className="w-full px-2 py-1 border rounded-md text-sm">
                            <option value="all">All Time</option>
                            <option value="lastYear">Last Year</option>
                            <option value="lastQuarter">Last Quarter</option>
                            <option value="lastMonth">Last Month</option>
                            <option value="lastWeek">Last Week</option>
                            <option value="yesterday">Yesterday</option>
                            <option value="custom">Custom Range</option>
                        </select>
                        {reportingPeriod.relative === 'custom' && <>
                            <div className="flex items-center space-x-2 mt-2">
                                <input type="date" value={reportingPeriod.start} onChange={e => setReportingPeriod(prev => ({...prev, start: e.target.value}))} className="w-full p-1 border rounded-md text-sm" />
                                <span>to</span>
                                <input type="date" value={reportingPeriod.end} onChange={e => setReportingPeriod(prev => ({...prev, end: e.target.value}))} className="w-full p-1 border rounded-md text-sm" />
                            </div>
                        </>}
                    </SidebarSection>

                    <SidebarSection title="Saved Reports" id="reports" isOpen={openSections.reports} onToggle={toggleSection}>
                        <div className="max-h-60 overflow-y-auto">
                            {savedReports.map((r) => (
                                <div key={r.id} className="flex items-center justify-between text-sm group pr-1">
                                    <button onClick={() => onLoadReport(r)} className="hover:underline text-left flex-grow truncate py-1">
                                        {r.name}
                                        <span className="text-gray-400 ml-1">{r.isPersonal ? '(Personal)' : '(Shared)'}</span>
                                    </button>
                                    <div className="hidden group-hover:flex items-center flex-shrink-0">
                                        <button onClick={() => setRenameModal(r)} className="p-1 hover:bg-gray-200 rounded text-xs"></button>
                                        <button onClick={() => setDeleteModal(r)} className="p-1 hover:bg-gray-200 rounded text-xs"></button>
                                    </div>
                                </div>
                            ))}
                            {savedReports.length === 0 && <p className="text-sm text-gray-400">No saved reports.</p>}
                        </div>
                    </SidebarSection>

                    <SidebarSection title="Columns" id="columns" isOpen={openSections.columns} onToggle={toggleSection}>
                        <div className="mt-2 space-y-1 max-h-60 overflow-y-auto">
                           {columns.map(col => (
                                <label key={col.key} className="flex items-center text-sm p-1 hover:bg-gray-50 rounded">
                                    <input type="checkbox" checked={col.visible} onChange={() => handleColumnToggle(col.key)} className="mr-2 h-4 w-4 text-cyan-600 border-gray-300 rounded focus:ring-cyan-500"/>
                                    <span className={col.isCustom ? 'italic' : ''}>{col.label}</span>
                                </label>
                            ))}
                        </div>
                    </SidebarSection>

                    <SidebarSection title="Purchase History" id="purchase" isOpen={openSections.purchase} onToggle={toggleSection}>
                        <input type="text" value={purchaseSearch} onChange={e => setPurchaseSearch(e.target.value)} placeholder="Search items..." className="w-full px-2 py-1 border rounded-md text-sm mb-2"/>
                        <div className="max-h-60 overflow-y-auto">
                            {filteredItems.map(item => (
                                <div key={item.id} className="flex items-center text-sm justify-between p-1">
                                    <span className="truncate">{item.item_data.name}</span>
                                    <div>
                                      <button onClick={() => setEditingFilter({ filter: { itemId: item.id, type: 'purchased', value: 'yes' }, index: null })} title="Filter by this item" className="ml-2 px-2 py-0.5 bg-blue-100 text-blue-700 rounded hover:bg-blue-200">Filter</button>
                                      <button onClick={() => onAddOrUpdatePurchaseColumn(item, 'yesNo')} title="Add as column" className="ml-1 px-2 py-0.5 bg-gray-200 rounded hover:bg-gray-300">Column</button>
                                    </div>
                                </div>
                            ))}
                        </div>
                    </SidebarSection>
                </div>
                {renameModal && <RenameModal report={renameModal} onRename={handleRename} onCancel={() => setRenameModal(null)} />}
                {deleteModal && <DeleteModal report={deleteModal} onDelete={handleDelete} onCancel={() => setDeleteModal(null)} />}
                {editingFilter && <PurchaseFilterModal item={catalogItems.find(i => i.id === editingFilter.filter.itemId)} onSave={handleSavePurchaseFilter} onCancel={() => setEditingFilter(null)} existingFilter={editingFilter.index !== null ? editingFilter.filter : null} />}
                </>
            );
        }

        function SaveReportModal({ onSave, onCancel }) {
            const [name, setName] = useState('');
            const [isShared, setIsShared] = useState(false);
            const [isWidget, setIsWidget] = useState(false);

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-40">
                    <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm">
                        <h3 className="font-bold text-lg">Save Report</h3>
                        <p className="text-sm text-gray-500 mt-2">Enter a name for this report configuration.</p>
                        <input 
                            type="text" 
                            value={name} 
                            onChange={(e) => setName(e.target.value)} 
                            className="w-full mt-4 px-3 py-2 border rounded-md" 
                            placeholder="Report Name" 
                        />
                        <label className="flex items-center mt-4 text-sm">
                            <input type="checkbox" checked={isWidget} onChange={e => setIsWidget(e.target.checked)} className="mr-2"/>
                            Add as a Dashboard Widget
                        </label>
                        <label className="flex items-center mt-2 text-sm">
                            <input type="checkbox" checked={isShared} onChange={e => setIsShared(e.target.checked)} className="mr-2"/>
                            Share with organization
                        </label>
                        <div className="mt-6 flex justify-end space-x-2">
                            <button onClick={onCancel} className="px-4 py-2 bg-gray-200 rounded-md">Cancel</button>
                            <button onClick={() => name && onSave(name, isWidget, isShared)} className="px-4 py-2 bg-cyan-600 text-white rounded-md">Save</button>
                        </div>
                    </div>
                </div>
            );
        }

        function RenameModal({ report, onRename, onCancel }) {
            const [newName, setNewName] = useState(report.name);

            const handleConfirm = () => {
                if (newName.trim()) {
                    onRename(newName.trim());
                }
            };

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-40">
                    <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm">
                        <h3 className="font-bold text-lg">Rename Report</h3>
                        <p className="text-sm text-gray-500 mt-2">Enter a new name for the report "{report.name}".</p>
                        <input 
                            type="text" 
                            value={newName} 
                            onChange={(e) => setNewName(e.target.value)} 
                            className="w-full mt-4 px-3 py-2 border rounded-md" 
                            placeholder="New Report Name" 
                        />
                        <div className="mt-6 flex justify-end space-x-2">
                            <button onClick={onCancel} className="px-4 py-2 bg-gray-200 rounded-md">Cancel</button>
                            <button onClick={handleConfirm} className="px-4 py-2 bg-cyan-600 text-white rounded-md">Rename</button>
                        </div>
                    </div>
                </div>
            );
        }

        function DeleteModal({ report, onDelete, onCancel }) {
            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-40">
                    <div className="bg-white rounded-lg shadow-xl p-6 w-full max-w-sm">
                        <h3 className="font-bold text-lg">Delete Report</h3>
                        <p className="text-sm text-gray-500 mt-2">Are you sure you want to delete the report "{report.name}"? This action cannot be undone.</p>
                        <div className="mt-6 flex justify-end space-x-2">
                            <button onClick={onCancel} className="px-4 py-2 bg-gray-200 rounded-md">Cancel</button>
                            <button onClick={onDelete} className="px-4 py-2 bg-red-600 text-white rounded-md">Delete</button>
                        </div>
                    </div>
                </div>
            );
        }

        function CustomerProfile({ customer, groupsMap, segmentsMap, customAttrDefs, onBack }) {
            
            const formatAddress = (address) => {
                if (!address) return 'N/A';
                const parts = [ address.address_line_1, address.address_line_2, `${address.locality || ''} ${address.administrative_district_level_1 || ''} ${address.postal_code || ''}`.trim(), address.country ];
                return parts.filter(Boolean).join(', ');
            };

            return (
                <div className="p-8">
                    <button onClick={onBack} className="mb-6 text-cyan-600 hover:text-cyan-800"> &larr; Back</button>
                    <div className="bg-white p-8 rounded-lg shadow-md">
                        <h2 className="text-4xl font-bold text-gray-800">{customer.given_name} {customer.family_name}</h2>
                        <p className="text-gray-500">Customer since {formatSimpleDate(customer.created_at)}</p>
                        
                        <div className="mt-8 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                            <InfoCard title="Contact Information">
                                <InfoItem label="Email" value={customer.email_address} />
                                <InfoItem label="Phone" value={customer.phone_number} />
                            </InfoCard>
                            <InfoCard title="Address">
                                <p className="text-gray-800">{formatAddress(customer.address)}</p>
                            </InfoCard>
                            <InfoCard title="Stats">
                                <InfoItem label="Last Visit" value={customer.last_visit ? formatDetailedDate(customer.last_visit) : 'No visits found'} />
                                <InfoItem label="Source" value={customer.creation_source} />
                            </InfoCard>
                            <InfoCard title="Details">
                                <InfoItem label="Birthday" value={customer.birthday ? formatSimpleDate(customer.birthday) : 'N/A'} />
                                <InfoItem label="Company" value={customer.company_name} />
                                <InfoItem label="Reference ID" value={customer.reference_id} />
                            </InfoCard>
                            <InfoCard title="Groups & Segments" className="lg:col-span-2">
                                <div className="flex flex-wrap gap-2">
                                    {(customer.group_ids || []).map(id => <Pill key={id} text={groupsMap.get(id) || id} />)}
                                    {(customer.segment_ids || []).map(id => <Pill key={id} text={segmentsMap.get(id) || id} color="bg-green-100 text-green-800" />)}
                                </div>
                            </InfoCard>
                            <InfoCard title="Custom Fields" className="md:col-span-3">
                                <div className="space-y-3">
                                    {Array.from(customAttrDefs.values()).map(def => (
                                        <InfoItem key={def.key} label={def.name} value={getNestedValue(customer, ['custom_attributes', def.key, 'value'])} />
                                    ))}
                                </div>
                            </InfoCard>
                            <InfoCard title="Notes" className="md:col-span-3">
                                <p className="text-gray-700 whitespace-pre-wrap">{customer.note || 'No notes for this customer.'}</p>
                            </InfoCard>
                        </div>
                    </div>
                </div>
            );
        }
        
        const InfoCard = ({ title, children, className }) => (<div className={`bg-white p-6 rounded-lg shadow-sm border ${className || ''}`}><h3 className="text-lg font-semibold text-gray-800 border-b pb-2 mb-4">{title}</h3><div className="space-y-3">{children}</div></div>);
        const InfoItem = ({ label, value }) => (<div><p className="text-sm text-gray-500">{label}</p><p className="font-medium text-gray-800">{value || 'N/A'}</p></div>);
        const Pill = ({ text, color = 'bg-gray-100 text-gray-800' }) => (<span className={`px-3 py-1 text-sm font-medium rounded-full ${color}`}>{text}</span>);
        const SidebarSection = ({ title, id, children, isOpen, onToggle }) => (
            <div>
                <button onClick={() => onToggle(id)} className="font-semibold w-full text-left flex justify-between items-center py-2">
                    {title}
                    <span className="transform transition-transform">{isOpen ? '' : '+'}</span>
                </button>
                {isOpen && <div className="mt-2 space-y-2 pl-2 border-l-2 border-gray-200">{children}</div>}
            </div>
        );

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>
