<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Social Medium CRM V4</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- React and Babel -->
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <!-- Firebase SDKs (Compat Version) -->
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore-compat.js"></script>
    <script>
        // --- Firebase Configuration ---
        const firebaseConfig = {
            apiKey: "AIzaSyCImFoyVJdVcRS-c7MXADhTQL7BGa20hHg",
            authDomain: "social-medium-crm.firebaseapp.com",
            projectId: "social-medium-crm",
            storageBucket: "social-medium-crm.appspot.com",
            messagingSenderId: "96565037485",
            appId: "1:96565037485:web:a7bb8427e2aae212b0b924",
            measurementId: "G-K3RE8VJE4S"
        };

        // Initialize Firebase
        firebase.initializeApp(firebaseConfig);
        const auth = firebase.auth();
        const db = firebase.firestore();
    </script>
    <style>
        body { font-family: 'Inter', sans-serif; }
        #root { height: 100vh; }
        .spinner { border: 2px solid rgba(0, 0, 0, 0.1); width: 20px; height: 20px; border-radius: 50%; border-left-color: #0891b2; animation: spin 1s ease infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useMemo, useCallback, useRef } = React;

        // --- Version Information ---
        const CRM_VERSION = "4.0";
        const CRM_VERSION_DESCRIPTION = "Implemented mobile-first responsive navigation.";

        // --- IMPORTANT: CUSTOM ATTRIBUTE KEYS ---
        const PRONOUNS_ATTR_KEY = "square:1af52fc0-c773-45be-8457-204a676fb763";
        const INSTAGRAM_ATTR_KEY = "square:8b9545ab-0e01-480c-a974-c28a7e71c96e";
        const LEGAL_NAME_ATTR_KEY = "square:ec552f4c-61bc-449e-9ae9-d9f641e18fc2";

        // --- Utility Functions ---
        const formatSimpleDate = (dateString) => {
            if (!dateString || dateString === 'N/A') return 'N/A';
            const date = new Date(dateString);
             // Adjust for timezone offset to prevent off-by-one day errors
            const userTimezoneOffset = date.getTimezoneOffset() * 60000;
            const adjustedDate = new Date(date.getTime() + userTimezoneOffset);
            if (isNaN(adjustedDate)) return 'N/A';
            return adjustedDate.toLocaleDateString();
        };

        const formatDetailedDate = (dateString) => {
            if (!dateString) return 'N/A';
            const date = new Date(dateString);
            if (isNaN(date)) return 'N/A';
            return date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric', hour: 'numeric', minute: 'numeric' });
        };

        const getNestedValue = (obj, path) => {
            if (!path) return undefined;
            return path.reduce((acc, part) => acc && acc[part], obj);
        }
        
        const delay = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        
        const getRelativeDateRange = (period) => {
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            let endDate = new Date(today);
            endDate.setHours(23, 59, 59, 999);
            let startDate = new Date(today);
            
            switch (period) {
                case 'Today':
                    // Start date is already today
                    break;
                case 'This Week':
                    const day = startDate.getDay();
                    const diff = startDate.getDate() - day + (day === 0 ? -6 : 1); // Adjust for Sunday as start of week
                    startDate = new Date(startDate.setDate(diff));
                    startDate.setHours(0, 0, 0, 0);
                    break;
                case 'This Month':
                    startDate = new Date(startDate.getFullYear(), startDate.getMonth(), 1);
                    break;
                case 'This Year':
                    startDate = new Date(startDate.getFullYear(), 0, 1);
                    break;
                case 'Last Day':
                    startDate.setDate(startDate.getDate() - 1);
                    break;
                case 'Last Week':
                    const lastWeekDay = startDate.getDay();
                    const lastWeekDiff = startDate.getDate() - lastWeekDay - 6; 
                    startDate = new Date(startDate.setDate(lastWeekDiff));
                    startDate.setHours(0, 0, 0, 0);
                    const lastWeekEnd = new Date(startDate);
                    lastWeekEnd.setDate(lastWeekEnd.getDate() + 6);
                    endDate = lastWeekEnd;
                    endDate.setHours(23, 59, 59, 999);
                    break;
                case 'This Quarter':
                    const currentMonth = today.getMonth();
                    const currentQuarterStartMonth = Math.floor(currentMonth / 3) * 3;
                    startDate = new Date(today.getFullYear(), currentQuarterStartMonth, 1);
                    startDate.setHours(0, 0, 0, 0);
                    const nextQuarterStartMonth = currentQuarterStartMonth + 3;
                    const nextQuarterStart = new Date(today.getFullYear(), nextQuarterStartMonth, 1);
                    endDate = new Date(nextQuarterStart.getTime() - 1);
                    break;
                case 'Last Quarter':
                    const month = today.getMonth();
                    const quarterStartMonth = Math.floor(month / 3) * 3;
                    startDate = new Date(today.getFullYear(), quarterStartMonth - 3, 1);
                    startDate.setHours(0, 0, 0, 0);
                    const quarterEnd = new Date(today.getFullYear(), quarterStartMonth, 0);
                    endDate = new Date(quarterEnd.getTime());
                    endDate.setHours(23, 59, 59, 999);
                    break;
            }
            return { startDate: startDate.toISOString(), endDate: endDate.toISOString() };
        };

        // --- Main App Component ---
        function App() {
            const [user, setUser] = useState(null);
            const [authLoading, setAuthLoading] = useState(true);
            const [squareAccessToken, setSquareAccessToken] = useState(null);
            const [isLoading, setIsLoading] = useState(false);
            const [loadingMessage, setLoadingMessage] = useState('');
            const [error, setError] = useState('');
            const [theme, setTheme] = useState(localStorage.getItem('theme') || 'light');
            const [isAdmin, setIsAdmin] = useState(false);
            
            // Data stores
            const [allCustomers, setAllCustomers] = useState([]);
            const [allOrders, setAllOrders] = useState([]);
            const [groupsMap, setGroupsMap] = useState(new Map());
            const [segmentsMap, setSegmentsMap] = useState(new Map());
            const [customAttrDefs, setCustomAttrDefs] = useState(new Map());
            const [locationId, setLocationId] = useState(null);
            const [personalReports, setPersonalReports] = useState([]);
            const [publicReports, setPublicReports] = useState([]);
            const [checklist, setChecklist] = useState([]);
            const [allUsers, setAllUsers] = useState([]);
            const [googleCalendarId, setGoogleCalendarId] = useState(null);
            const [displayChecklist, setDisplayChecklist] = useState([]);
            const [cheatSheetContent, setCheatSheetContent] = useState('');
            
            // View management
            const [currentView, setCurrentView] = useState('dashboard');
            const [reportToLoad, setReportToLoad] = useState(null);
            const [profileModalState, setProfileModalState] = useState({ isOpen: false, customer: null });
            const [noteEditorState, setNoteEditorState] = useState({ isOpen: false, customer: null });
            const [isCheatSheetOpen, setIsCheatSheetOpen] = useState(false);
            const [taskCreatorState, setTaskCreatorState] = useState({ isOpen: false, customer: null });
            const [pendingNoteEditOnLog, setPendingNoteEditOnLog] = useState(false);


            const API_PROXY_URL = 'https://square-checkin-backend.onrender.com';
            const contactedMartinItemId = "376G3V4PU6H6VE6MEREUY3TD";

            useEffect(() => {
                if (theme === 'dark') {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
                localStorage.setItem('theme', theme);
            }, [theme]);

            useEffect(() => {
                if (pendingNoteEditOnLog && profileModalState.customer) {
                    setNoteEditorState({ isOpen: true, customer: profileModalState.customer });
                    setPendingNoteEditOnLog(false);
                }
            }, [profileModalState.customer, pendingNoteEditOnLog]);

            const toggleTheme = () => {
                setTheme(prevTheme => prevTheme === 'light' ? 'dark' : 'light');
            };

            const apiFetch = async (endpoint, options = {}) => {
                const response = await fetch(`${API_PROXY_URL}/api${endpoint}`, {
                    ...options,
                    headers: { ...options.headers, 'x-square-access-token': squareAccessToken, 'Content-Type': 'application/json' },
                });
                const data = await response.json();
                if (!response.ok) throw new Error(data.errors?.[0]?.detail || data.error || 'An API error occurred.');
                return data;
            };
            
            useEffect(() => {
                const unsubscribe = auth.onAuthStateChanged(user => {
                    setUser(user);
                    setAuthLoading(false);
                    if (user) {
                        const userDocRef = db.collection('users').doc(user.uid);
                        userDocRef.get().then(doc => {
                            if (doc.exists) {
                                const data = doc.data();
                                setIsAdmin(data.isAdmin || false);
                            } else {
                                userDocRef.set({ email: user.email, isAdmin: false, squareAccessToken: null, savedReports: [] });
                                setIsAdmin(false);
                            }
                        });
                    }
                });
                return () => unsubscribe();
            }, []);

            useEffect(() => {
                if (user) {
                    const userDocRef = db.collection('users').doc(user.uid);
                    const publicReportsDocRef = db.collection('public').doc('reports');
                    const settingsDocRef = db.collection('public').doc('settings');
                    const cheatSheetDocRef = db.collection('public').doc('cheatSheet');
                    
                    const deserializeReports = (reports = []) => {
                        return reports.map(report => ({
                            ...report,
                            filters: Object.entries(report.filters || {}).reduce((acc, [key, val]) => {
                                acc[key] = { ...val, values: new Set(val.values || []), excludedValues: new Set(val.excludedValues || []) };
                                if (val.relative_date_range) {
                                     acc[key].date_range = getRelativeDateRange(val.relative_date_range);
                                }
                                if (val.excluded_relative_date_range) {
                                    acc[key].excluded_date_range = getRelativeDateRange(val.excluded_relative_date_range);
                                }
                                return acc;
                            }, {}),
                        }));
                    };

                    const unsubscribeUser = userDocRef.onSnapshot((doc) => {
                        if (doc.exists) {
                            const data = doc.data();
                            setSquareAccessToken(data.squareAccessToken || null);
                            setPersonalReports(deserializeReports(data.savedReports));
                        } else {
                            userDocRef.set({ squareAccessToken: null, savedReports: [] });
                        }
                    });

                    const unsubscribePublic = publicReportsDocRef.onSnapshot((doc) => {
                        if (doc.exists) {
                            setPublicReports(deserializeReports(doc.data().allReports));
                        }
                    });

                    const unsubscribeSettings = settingsDocRef.onSnapshot((doc) => {
                        if (doc.exists) {
                            setGoogleCalendarId(doc.data().googleCalendarId);
                        }
                    });
                    
                    const allUsersUnsubscribe = db.collection('users').onSnapshot(snapshot => {
                        const users = snapshot.docs.map(doc => ({
                            id: doc.id,
                            ...doc.data()
                        }));
                        setAllUsers(users);
                    });

                    const unsubscribeCheatSheet = cheatSheetDocRef.onSnapshot(doc => {
                        if (doc.exists) {
                            setCheatSheetContent(doc.data().content || '');
                        }
                    });


                    return () => {
                        unsubscribeUser();
                        unsubscribePublic();
                        allUsersUnsubscribe();
                        unsubscribeSettings();
                        unsubscribeCheatSheet();
                    };
                }
            }, [user]);

            useEffect(() => {
                if (!user || authLoading) return;

                let query;
                if (isAdmin) {
                    query = db.collectionGroup('checklists');
                } else {
                    query = db.collection('users').doc(user.uid).collection('checklists');
                }
                
                const unsubscribe = query.onSnapshot(snapshot => {
                    let items = snapshot.docs.map(doc => ({
                        id: doc.id,
                        userId: doc.ref.parent.parent.id,
                        ...doc.data()
                    }));
                    
                    setChecklist(items);
                }, error => {
                    console.error("Error fetching checklist:", error);
                    setError("Could not load the checklist due to a database error.");
                });

                return () => unsubscribe();
            }, [user, isAdmin, authLoading]);

            useEffect(() => {
                if (isAdmin && allUsers.length > 0) {
                    const userMap = new Map();
                    allUsers.forEach(user => {
                        userMap.set(user.id, user.name || user.email || 'No Email');
                    });

                    const itemsByUser = checklist.reduce((acc, item) => {
                        const userId = item.userId;
                        if (!acc[userId]) {
                            acc[userId] = [];
                        }
                        acc[userId].push(item);
                        return acc;
                    }, {});

                    const groupedChecklists = Object.keys(itemsByUser).map(userId => {
                        const items = itemsByUser[userId];
                        return {
                            userId: userId,
                            userIdentifier: userMap.get(userId) || 'Unknown User',
                            items: items
                        };
                    }).sort((a, b) => a.userIdentifier.localeCompare(b.userIdentifier));
                    
                    setDisplayChecklist(groupedChecklists);
                } else {
                    setDisplayChecklist(checklist);
                }
            }, [checklist, allUsers, isAdmin]);

            const handleAddChecklistItem = async (text, dueDate) => {
                if (user && text.trim() !== '') {
                    const checklistCollectionRef = db.collection('users').doc(user.uid).collection('checklists');
                    await checklistCollectionRef.add({
                        text,
                        completed: false,
                        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
                        dueDate: dueDate || null,
                    });
                }
            };
            
            const handleUpdateChecklistItem = async (userId, itemId, completed) => {
                if (user) {
                    const itemRef = db.collection('users').doc(userId).collection('checklists').doc(itemId);
                    await itemRef.update({ completed });
                }
            };
            
            const handleDeleteChecklistItem = async (userId, itemId) => {
                if (user) {
                    const itemRef = db.collection('users').doc(userId).collection('checklists').doc(itemId);
                    await itemRef.delete();
                }
            };

            const fetchAllCustomers = useCallback(async () => {
                setLoadingMessage('Fetching all customers...');
                let fetchedCustomers = [];
                let cursor = undefined;
                do {
                    const data = await apiFetch('/v2/customers/search', {
                        method: 'POST',
                        body: JSON.stringify({ query: { sort: { field: "CREATED_AT", order: "DESC" } }, cursor: cursor })
                    });
                    if (data.customers) fetchedCustomers.push(...data.customers);
                    cursor = data.cursor;
                    if (cursor) await delay(200);
                } while (cursor);
                
                const uniqueCustomers = Array.from(new Map(fetchedCustomers.map(customer => [customer.id, customer])).values());

                uniqueCustomers.sort((a, b) => (a.given_name || '').localeCompare(b.given_name || ''));
                setAllCustomers(uniqueCustomers);
            }, [squareAccessToken]);

            const fetchAllOrders = useCallback(async (locationId) => {
                setLoadingMessage('Fetching all orders...');
                
                const customerMapByContact = new Map();
                for (const customer of allCustomers) {
                    if (customer.given_name && customer.phone_number) {
                        const key = `${customer.given_name.toLowerCase().trim()}-${customer.phone_number.replace(/\D/g, '')}`;
                        customerMapByContact.set(key, customer.id);
                    }
                }

                let fetchedOrders = [];
                let cursor = undefined;
                do {
                    const data = await apiFetch('/v2/orders/search', {
                        method: 'POST',
                        body: JSON.stringify({
                            location_ids: [locationId],
                            cursor: cursor
                        })
                    });
                    
                    if (data && data.orders) {
                        const ordersWithCustomerId = data.orders.map(order => {
                            if (!order.customer_id && order.fulfillments?.[0]?.pickup_details?.recipient?.given_name && order.fulfillments?.[0]?.pickup_details?.recipient?.phone_number) {
                                const recipient = order.fulfillments[0].pickup_details.recipient;
                                const key = `${recipient.given_name.toLowerCase().trim()}-${recipient.phone_number.replace(/\D/g, '')}`;
                                const matchedCustomerId = customerMapByContact.get(key);
                                if (matchedCustomerId) {
                                    return { ...order, customer_id: matchedCustomerId };
                                }
                            }
                            return order;
                        });

                        fetchedOrders.push(...ordersWithCustomerId);
                    }
                    cursor = data.cursor;
                    if (cursor) await delay(200);
                } while (cursor);

                const lastContactDates = new Map();
                for (const order of fetchedOrders) {
                    if (order.line_items && order.customer_id) {
                        const contactItem = order.line_items.find(item => item.catalog_object_id === contactedMartinItemId);
                        if (contactItem) {
                            const existingDate = lastContactDates.get(order.customer_id);
                            if (!existingDate || new Date(order.closed_at) > new Date(existingDate)) {
                                lastContactDates.set(order.customer_id, order.closed_at);
                            }
                        }
                    }
                }

                const customersWithContactDates = allCustomers.map(customer => ({
                    ...customer,
                    last_sms_contact: lastContactDates.get(customer.id) || null
                }));

                setAllCustomers(customersWithContactDates);

                const flattenedItems = fetchedOrders.flatMap(order => 
                    (order.line_items || []).map(item => ({
                        item_uid: `${order.id}-${item.uid}`,
                        order_id: order.id,
                        customer_id: order.customer_id,
                        line_item_name: item.name,
                        quantity: parseFloat(item.quantity),
                        purchase_date: order.closed_at,
                        order_total: order.total_money.amount / 100
                    }))
                );
                
                setAllOrders(flattenedItems);
            }, [squareAccessToken, allCustomers]);

            useEffect(() => {
                if (squareAccessToken) {
                    const fetchAllCustomAttributeDefinitions = async () => {
                        let definitions = [];
                        let cursor = undefined;
                        do {
                            const endpoint = cursor ? `/v2/customers/custom-attribute-definitions?cursor=${cursor}` : '/v2/customers/custom-attribute-definitions';
                            const data = await apiFetch(endpoint);
                            if (data.custom_attribute_definitions) {
                                definitions.push(...data.custom_attribute_definitions);
                            }
                            cursor = data.cursor;
                            if (cursor) await delay(200);
                        } while (cursor);
                        return definitions;
                    };

                    const fetchInitialData = async () => {
                        setIsLoading(true);
                        setLoadingMessage('Fetching initial data...');
                        setError('');
                        try {
                            const [groupsData, segmentsData, locationData, customAttrData] = await Promise.all([
                                apiFetch('/v2/customers/groups'),
                                apiFetch('/v2/customers/segments'),
                                apiFetch('/v2/locations'),
                                fetchAllCustomAttributeDefinitions()
                            ]);

                            if (groupsData.groups) setGroupsMap(new Map(groupsData.groups.map(g => [g.id, g.name])));
                            if (segmentsData.segments) setSegmentsMap(new Map(segmentsData.segments.map(s => [s.id, s.name])));
                            setCustomAttrDefs(new Map(customAttrData.map(def => [def.key, def])));
                            
                            const activeLocation = locationData.locations?.find(loc => loc.status === 'ACTIVE');
                            if (activeLocation) {
                                setLocationId(activeLocation.id);
                                await fetchAllCustomers();
                            } else {
                                throw new Error("No active location found for this business.");
                            }

                        } catch (err) {
                            if (err.message.toLowerCase().includes('authorized')) {
                                console.error("[AUTH] Invalid token detected. Clearing token and prompting for a new one.");
                                const userDocRef = db.collection('users').doc(user.uid);
                                await userDocRef.update({ squareAccessToken: null });
                                setSquareAccessToken(null);
                                setError('');
                            } else {
                                setError(err.message);
                            }
                        } finally {
                            setIsLoading(false);
                            setLoadingMessage('');
                        }
                    };
                    
                    fetchInitialData();
                }
            }, [squareAccessToken, user, fetchAllCustomers]);
            
            useEffect(() => {
                if (allCustomers.length > 0 && locationId) {
                    fetchAllOrders(locationId);
                }
            }, [allCustomers, locationId, fetchAllOrders]);
            
            const handleUpdateCustomAttribute = async (customerId, attributeKey, value) => {
                try {
                    const payload = { custom_attribute: { value } };
                    const { custom_attribute } = await apiFetch(`/v2/customers/${customerId}/custom-attributes/${attributeKey}`, {
                        method: 'POST',
                        body: JSON.stringify(payload),
                    });

                    setAllCustomers(prevCustomers => 
                        prevCustomers.map(c => {
                            if (c.id === customerId) {
                                return { ...c, custom_attributes: { ...c.custom_attributes, [attributeKey]: custom_attribute }, version: custom_attribute.version };
                            }
                            return c;
                        })
                    );

                    setProfileModalState(prevState => ({
                        ...prevState,
                        customer: { ...prevState.customer, custom_attributes: { ...prevState.customer.custom_attributes, [attributeKey]: custom_attribute }, version: custom_attribute.version }
                    }));

                } catch (err) {
                    console.error("Failed to update custom attribute:", err);
                    setError("Could not update custom attribute. Please try again.");
                }
            };
            
            const handleUpdateNote = async (customerId, note) => {
                try {
                    const { customer } = await apiFetch(`/v2/customers/${customerId}`, {
                        method: 'PUT',
                        body: JSON.stringify({ note }),
                    });
                    setAllCustomers(prevCustomers => prevCustomers.map(c => (c.id === customerId ? customer : c)));
                    setProfileModalState(prevState => ({ ...prevState, customer }));
                    setNoteEditorState({ isOpen: false, customer: null });
                } catch (err) {
                    console.error("Failed to update note:", err);
                    setError("Could not update note. Please try again.");
                }
            };

            const handleLogContact = async (customerId) => {
                if (!locationId) {
                    setError("Location ID is not set. Cannot log contact.");
                    return;
                }
                
                const orderPayload = {
                    idempotency_key: crypto.randomUUID(),
                    order: {
                        location_id: locationId,
                        customer_id: customerId,
                        line_items: [{ catalog_object_id: contactedMartinItemId, quantity: '1' }]
                    }
                };

                try {
                    const orderData = await apiFetch('/v2/orders', { method: 'POST', body: JSON.stringify(orderPayload) });
                    const payPayload = { idempotency_key: crypto.randomUUID(), payment_ids: [] };
                    await apiFetch(`/v2/orders/${orderData.order.id}/pay`, { method: 'POST', body: JSON.stringify(payPayload) });
                    await delay(1000);
                    handleSelectCustomer(profileModalState.customer, true);
                    setPendingNoteEditOnLog(true);

                } catch (err) {
                    console.error("Failed to log contact:", err);
                    setError("Could not log contact. Please try again.");
                }
            };
            
            const handleSaveContact = (customer) => {
                const pronouns = getNestedValue(customer, ['custom_attributes', PRONOUNS_ATTR_KEY, 'value']) || '';
                const instagram = getNestedValue(customer, ['custom_attributes', INSTAGRAM_ATTR_KEY, 'value']) || '';

                let note = '';
                if (pronouns) note += `Pronouns: ${pronouns}\\n`;
                if (instagram) note += `Instagram: @${instagram.replace('@', '')}\\n`;

                const vCard = `BEGIN:VCARD
VERSION:3.0
FN:${customer.given_name || ''} ${customer.family_name || ''}
N:${customer.family_name || ''};${customer.given_name || ''};;;
TEL;TYPE=CELL:${customer.phone_number || ''}
EMAIL:${customer.email_address || ''}
NOTE:${note}
END:VCARD`;

                const blob = new Blob([vCard], { type: 'text/vcard;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${customer.given_name || 'contact'}_${customer.family_name || ''}.vcf`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            const handleSelectCustomer = (customer, isRefresh = false) => {
                if (!isRefresh) {
                    setIsLoading(true);
                    setProfileModalState({ isOpen: true, customer: customer });
                }
                setError('');
                
                const fetchDetails = async () => {
                    if (!locationId) {
                        setError("Location ID is not set. Cannot fetch orders.");
                        setIsLoading(false);
                        return;
                    }

                    try {
                        const [customerData, customAttributesData] = await Promise.all([
                            apiFetch(`/v2/customers/${customer.id}`),
                            apiFetch(`/v2/customers/${customer.id}/custom-attributes`)
                        ]);
                        
                        const customerOrdersData = await apiFetch('/v2/orders/search', {
                            method: 'POST',
                            body: JSON.stringify({
                                location_ids: [locationId],
                                query: {
                                    filter: { customer_filter: { customer_ids: [customer.id] }, state_filter: { states: ["COMPLETED"] } },
                                    sort: { sort_field: "CLOSED_AT", sort_order: "DESC" }
                                }
                            })
                        });
                        
                        let lastSmsContactDate = null;
                        const allOrders = customerOrdersData.orders || [];
                        
                        for (const order of allOrders) {
                            if (order.line_items) {
                                const contactItem = order.line_items.find(item => item.catalog_object_id === contactedMartinItemId);
                                if (contactItem) {
                                    lastSmsContactDate = order.closed_at;
                                    break;
                                }
                            }
                        }

                        // Find associated tasks
                        const associatedTasks = checklist.filter(item => item.text && item.text.startsWith(customer.id + '@@'));

                        const fullCustomerProfile = { 
                            ...customerData.customer, 
                            orders: allOrders,
                            last_visit: allOrders?.[0]?.closed_at,
                            last_sms_contact: lastSmsContactDate,
                            custom_attributes: (customAttributesData.custom_attributes || []).reduce((acc, attr) => {
                                acc[attr.key] = attr;
                                return acc;
                            }, {}),
                            associatedTasks: associatedTasks,
                        };
                        setProfileModalState({ isOpen: true, customer: fullCustomerProfile });
                    } catch (err) {
                        setError(err.message);
                    } finally {
                        setIsLoading(false);
                    }
                };
                
                fetchDetails();
            };
            
            const serializeReport = (report) => {
                const serializedFilters = {};
                if (report.filters) {
                    for (const key in report.filters) {
                        const filterConfig = report.filters[key];
                        serializedFilters[key] = {
                            ...filterConfig,
                            values: Array.from(filterConfig.values || []),
                            excludedValues: Array.from(filterConfig.excludedValues || []),
                        };
                        if (filterConfig.date_range) {
                            serializedFilters[key].date_range = { startDate: filterConfig.date_range.startDate, endDate: filterConfig.date_range.endDate };
                        }
                        if (filterConfig.excluded_date_range) {
                            serializedFilters[key].excluded_date_range = { startDate: filterConfig.excluded_date_range.startDate, endDate: filterConfig.excluded_date_range.endDate };
                        }
                    }
                }
                const newReport = { ...report, filters: serializedFilters };
                delete newReport.isPersonal;
                return newReport;
            };

            const handleSaveReport = async (report, isWidget, isShared) => {
                const reportWithId = { ...report, id: report.id || crypto.randomUUID(), isWidget };
                const serializedReport = serializeReport(reportWithId);

                if (isShared) {
                    const publicReportsDocRef = db.collection('public').doc('reports');
                    try {
                         await publicReportsDocRef.update({ allReports: firebase.firestore.FieldValue.arrayUnion(serializedReport) });
                    } catch (err) {
                        if (err.code === 'not-found') {
                            await publicReportsDocRef.set({ allReports: [serializedReport] });
                        } else {
                           console.error("Error saving shared report:", err);
                           setError("Could not save shared report.");
                        }
                    }
                } else {
                    const userDocRef = db.collection('users').doc(user.uid);
                    await userDocRef.update({ savedReports: firebase.firestore.FieldValue.arrayUnion(serializedReport) });
                }
            };
            
            const handleUpdateReport = async (updatedReport) => {
                const serializedReport = serializeReport(updatedReport);
                if (updatedReport.isPersonal) {
                    const userDocRef = db.collection('users').doc(user.uid);
                    const updatedPersonalReports = personalReports.map(r => r.id === updatedReport.id ? updatedReport : r);
                    await userDocRef.update({ savedReports: updatedPersonalReports.map(serializeReport) });
                } else {
                    const publicReportsDocRef = db.collection('public').doc('reports');
                    const updatedPublicReports = publicReports.map(r => r.id === updatedReport.id ? updatedReport : r);
                    await publicReportsDocRef.set({ allReports: updatedPublicReports.map(serializeReport) });
                }
            };

            const handleDeleteReport = async (reportId, isPersonal) => {
                if (isPersonal) {
                    const userDocRef = db.collection('users').doc(user.uid);
                    const doc = await userDocRef.get();
                    if (doc.exists) {
                        const currentReports = doc.data().savedReports || [];
                        const updatedReports = currentReports.filter(r => r.id !== reportId);
                        await userDocRef.update({ savedReports: updatedReports });
                    }
                } else {
                    const publicReportsDocRef = db.collection('public').doc('reports');
                    const doc = await publicReportsDocRef.get();
                    if (doc.exists) {
                        const currentReports = doc.data().allReports || [];
                        const updatedReports = currentReports.filter(r => r.id !== reportId);
                        await publicReportsDocRef.update({ allReports: updatedReports });
                    }
                }
            };
            
            const handleNavigate = (view, payload = null) => {
                if (view === 'reports' && payload) {
                    setReportToLoad(payload);
                }
                setCurrentView(view);
            };

            const handleSaveToken = async (token) => {
                if (user) {
                    await db.collection('users').doc(user.uid).update({ squareAccessToken: token });
                    setSquareAccessToken(token);
                }
            };

            const currentUserChecklist = useMemo(() => {
                if (!user) return [];
                return checklist.filter(task => task.userId === user.uid);
            }, [checklist, user?.uid]);
            
            if (authLoading) {
                return <div className="flex justify-center items-center h-full"><div className="spinner"></div></div>;
            }

            if (!user) {
                return <AuthPage />;
            }

            if (!squareAccessToken) {
                return <SettingsPage onSaveToken={handleSaveToken} userEmail={user.email} />;
            }
            
            const combinedReports = [...(personalReports || []).map(r => ({...r, isPersonal: true})), ...(publicReports || []).map(r => ({...r, isPersonal: false}))];
            const widgets = combinedReports.filter(r => r.isWidget);

            const renderMainContent = () => {
                if (isLoading && !profileModalState.isOpen) return <div className="flex justify-center items-center h-full"><div className="spinner"></div><p className="ml-2">{loadingMessage}</p></div>;
                if (error) return <div className="p-4 m-4 bg-red-100 text-red-700 rounded-md text-center">{error}</div>;

                switch(currentView) {
                    case 'reports':
                        return <ReportsPage allCustomers={allCustomers} allOrders={allOrders} groupsMap={groupsMap} segmentsMap={segmentsMap} customAttrDefs={customAttrDefs} onSelectCustomer={handleSelectCustomer} onBack={() => setCurrentView('dashboard')} savedReports={combinedReports} onSaveReport={handleSaveReport} onUpdateReport={handleUpdateReport} onDeleteReport={handleDeleteReport} initialReport={reportToLoad} onInitialReportLoaded={() => setReportToLoad(null)} totalCustomers={allCustomers.length} isAdmin={isAdmin} />;
                    case 'directory':
                        return <DirectoryPage allCustomers={allCustomers} onSelectCustomer={handleSelectCustomer} onBack={() => setCurrentView('dashboard')} />;
                    case 'checklist':
                        return <ChecklistPage checklist={displayChecklist} onAdd={handleAddChecklistItem} onUpdate={handleUpdateChecklistItem} onDelete={handleDeleteChecklistItem} onBack={() => setCurrentView('dashboard')} isAdmin={isAdmin} onSelectCustomer={handleSelectCustomer} />;
                    case 'admin':
                        return <AdminPage allUsers={allUsers} cheatSheetContent={cheatSheetContent} onBack={() => setCurrentView('dashboard')} />;
                    case 'dashboard':
                    default:
                        return <Dashboard onNavigate={handleNavigate} widgets={widgets} allCustomers={allCustomers} allOrders={allOrders} groupsMap={groupsMap} segmentsMap={segmentsMap} onSelectCustomer={handleSelectCustomer} totalCustomers={allCustomers.length} googleCalendarId={googleCalendarId} checklist={currentUserChecklist} onUpdateChecklistItem={handleUpdateChecklistItem} currentUserId={user.uid} />;
                }
            };

            return (
                <div className="h-screen flex flex-col">
                    <Toolbar onNavigate={handleNavigate} onToggleCheatSheet={() => setIsCheatSheetOpen(true)} theme={theme} toggleTheme={toggleTheme} isAdmin={isAdmin} />
                    <main className="flex-1 overflow-y-auto bg-gray-100 dark:bg-gray-800">
                        {renderMainContent()}
                    </main>
                    {profileModalState.isOpen && (
                        <CustomerProfileModal
                            customer={profileModalState.customer}
                            isLoading={isLoading}
                            onClose={() => setProfileModalState({ isOpen: false, customer: null })}
                            groupsMap={groupsMap}
                            segmentsMap={segmentsMap}
                            customAttrDefs={customAttrDefs}
                            onLogContact={handleLogContact}
                            onSaveContact={handleSaveContact}
                            onEditNoteRequest={(customer) => setNoteEditorState({ isOpen: true, customer: customer })}
                            onCreateTaskRequest={(customer) => setTaskCreatorState({isOpen: true, customer: customer})}
                            onUpdateTask={handleUpdateChecklistItem}
                            onDeleteTask={handleDeleteChecklistItem}
                        />
                    )}
                     {noteEditorState.isOpen && (
                        <NoteEditorModal
                            customer={noteEditorState.customer}
                            onSave={handleUpdateNote}
                            onCancel={() => setNoteEditorState({ isOpen: false, customer: null })}
                        />
                    )}
                    {isCheatSheetOpen && (
                        <CheatSheetModal
                            content={cheatSheetContent}
                            onClose={() => setIsCheatSheetOpen(false)}
                        />
                    )}
                    {taskCreatorState.isOpen && (
                        <TaskCreatorModal
                            customer={taskCreatorState.customer}
                            onSave={handleAddChecklistItem}
                            onCancel={() => setTaskCreatorState({ isOpen: false, customer: null })}
                        />
                    )}
                </div>
            );
        }

        // --- Child Components ---

        function Toolbar({ onNavigate, onToggleCheatSheet, theme, toggleTheme, isAdmin }) {
            return (
                <header className="bg-white dark:bg-gray-900 shadow-md p-4 flex justify-between items-center z-20">
                    <h1 className="text-2xl font-bold text-cyan-700 dark:text-cyan-400">Social Medium CRM</h1>
                    <div className="flex items-center space-x-2">
                        <button onClick={onToggleCheatSheet} className="p-2 rounded-full text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-800" title="Cheat Sheet">
                             <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z" /></svg>
                        </button>
                        <button onClick={toggleTheme} className="p-2 rounded-full text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-800" title={theme === 'light' ? 'Dark Mode' : 'Light Mode'}>
                            {theme === 'light' ? 
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" /></svg> : 
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" /></svg>
                            }
                        </button>
                        <button onClick={() => onNavigate('dashboard')} className="p-2 rounded-full text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-800" title="Dashboard">
                             <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M4 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2V6zM14 6a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2V6zM4 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2H6a2 2 0 01-2-2v-2zM14 16a2 2 0 012-2h2a2 2 0 012 2v2a2 2 0 01-2 2h-2a2 2 0 01-2-2v-2z" /></svg>
                        </button>
                        <button onClick={() => onNavigate('checklist')} className="p-2 rounded-full text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-800" title="Checklist">
                             <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4" /></svg>
                        </button>
                        {isAdmin && <button onClick={() => onNavigate('admin')} className="p-2 rounded-full text-gray-500 dark:text-gray-400 hover:bg-gray-100 dark:hover:bg-gray-800" title="Admin">
                             <svg xmlns="http://www.w3.org/2000/svg" className="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>
                        </button>}
                        <button onClick={() => auth.signOut()} className="px-4 py-2 bg-cyan-600 text-white rounded-md text-sm font-medium hover:bg-cyan-700">Logout</button>
                    </div>
                </header>
            );
        }

        function AuthPage() {
            const [isLogin, setIsLogin] = useState(true);
            const [email, setEmail] = useState('');
            const [password, setPassword] = useState('');
            const [error, setError] = useState('');

            const handleSubmit = async (e) => {
                e.preventDefault();
                setError('');
                try {
                    if (isLogin) {
                        await auth.signInWithEmailAndPassword(email, password);
                    } else {
                        await auth.createUserWithEmailAndPassword(email, password);
                    }
                } catch (err) {
                    setError(err.message);
                }
            };

            return (
                <div className="flex items-center justify-center h-full">
                    <div className="w-full max-w-md p-8 bg-white dark:bg-gray-800 rounded-lg shadow-md">
                        <h1 className="text-2xl font-bold text-center text-gray-800 dark:text-gray-200">{isLogin ? 'Login' : 'Sign Up'}</h1>
                        <form onSubmit={handleSubmit} className="mt-6 space-y-4">
                            <input type="email" value={email} onChange={e => setEmail(e.target.value)} placeholder="Email" required className="w-full px-4 py-2 border rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white" />
                            <input type="password" value={password} onChange={e => setPassword(e.target.value)} placeholder="Password" required className="w-full px-4 py-2 border rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white" />
                            <button type="submit" className="w-full px-6 py-2 text-white bg-cyan-600 rounded-md hover:bg-cyan-700">{isLogin ? 'Login' : 'Sign Up'}</button>
                            {error && <p className="text-red-500 text-sm text-center">{error}</p>}
                        </form>
                        
                        <button onClick={() => setIsLogin(!isLogin)} className="mt-4 text-sm text-cyan-600 dark:text-cyan-400 hover:underline w-full text-center">
                            {isLogin ? 'Need an account? Sign Up' : 'Already have an account? Login'}
                        </button>
                    </div>
                </div>
            );
        }

        function SettingsPage({ onSaveToken, userEmail }) {
            const [token, setToken] = useState('');
            return (
                <div className="flex items-center justify-center h-full">
                    <div className="w-full max-w-md p-8 bg-white dark:bg-gray-800 rounded-lg shadow-md text-center">
                        <h1 className="text-2xl font-bold text-gray-800 dark:text-gray-200">Connect to Square</h1>
                        <p className="text-gray-500 dark:text-gray-400 mt-2 mb-6">Welcome, {userEmail}! Please enter your Square Access Token to continue.</p>
                        <div className="flex items-center space-x-3">
                            <input type="password" value={token} onChange={(e) => setToken(e.target.value)} className="flex-grow block w-full px-4 py-2 text-gray-700 bg-white border border-gray-300 rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white" placeholder="Square Access Token" />
                            <button onClick={() => onSaveToken(token)} className="px-6 py-2 text-white bg-cyan-600 rounded-md hover:bg-cyan-700">Save</button>
                        </div>
                        <button onClick={() => auth.signOut()} className="mt-8 text-sm text-gray-500 dark:text-gray-400 hover:underline">Logout</button>
                    </div>
                </div>
            );
        }

        function Dashboard({ onNavigate, widgets, allCustomers, allOrders, groupsMap, segmentsMap, onSelectCustomer, googleCalendarId, checklist, onUpdateChecklistItem, currentUserId, isAdmin }) {
            const handleWidgetClick = (widget) => {
                onNavigate('reports', widget);
            };
            return (
                <div className="p-8">
                    <h2 className="text-4xl font-bold text-gray-800 dark:text-gray-200">Dashboard</h2>
                    <p className="text-gray-500 dark:text-gray-400">Welcome to your Social Medium CRM.</p>
                    
                    <div className="mt-8 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                        <button onClick={() => onNavigate('directory')} className="p-6 bg-white dark:bg-gray-800 rounded-lg shadow hover:bg-cyan-50 dark:hover:bg-gray-700 text-left transition">
                            <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200">Directory</h3>
                            <p className="text-gray-500 dark:text-gray-400 mt-2">Search and view all customers.</p>
                        </button>
                        <button onClick={() => onNavigate('reports')} className="p-6 bg-white dark:bg-gray-800 rounded-lg shadow hover:bg-cyan-50 dark:hover:bg-gray-700 text-left transition">
                            <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200">Reports</h3>
                            <p className="text-gray-500 dark:text-gray-400 mt-2">Filter customers by profile information.</p>
                        </button>
                        {widgets.map((widget) => (
                            <DashboardWidget 
                                key={widget.id} 
                                widget={widget} 
                                allCustomers={allCustomers} 
                                allOrders={allOrders} 
                                groupsMap={groupsMap} 
                                segmentsMap={segmentsMap} 
                                onWidgetClick={handleWidgetClick} 
                            />
                        ))}
                    </div>
                     {checklist && checklist.length > 0 && (
                        <div className="mt-8">
                            <ChecklistWidget
                                checklist={checklist}
                                onUpdate={onUpdateChecklistItem}
                                onSelectCustomer={onSelectCustomer}
                                userId={currentUserId}
                                onNavigate={onNavigate}
                            />
                        </div>
                    )}
                    {googleCalendarId && (
                        <div className="mt-8">
                           <CalendarWidget calendarId={googleCalendarId} />
                        </div>
                    )}
                </div>
            );
        }

        function ChecklistWidget({ checklist, onUpdate, onSelectCustomer, userId, onNavigate }) {

            const categorizedTasks = useMemo(() => {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);

                const overdue = [];
                const dueToday = [];

                checklist.forEach(item => {
                    if (item.completed) return;

                    if (!item.dueDate) {
                        dueToday.push(item);
                    } else {
                        const dueDate = new Date(item.dueDate);
                        // Adjust for timezone offset
                        const userTimezoneOffset = dueDate.getTimezoneOffset() * 60000;
                        const adjustedDueDate = new Date(dueDate.getTime() + userTimezoneOffset);

                        if (adjustedDueDate < today) overdue.push(item);
                        else if (adjustedDueDate < tomorrow) dueToday.push(item);
                    }
                });
                
                const sortItems = (items) => items.sort((a, b) => (new Date(a.dueDate) || 0) - (new Date(b.dueDate) || 0));

                return { overdue: sortItems(overdue), dueToday: sortItems(dueToday) };
            }, [checklist]);

            if (categorizedTasks.overdue.length === 0 && categorizedTasks.dueToday.length === 0) {
                return null;
            }

            const renderTaskText = (item) => {
                const text = item.text || '';
                if (text.includes('@@')) {
                    const [customerId, rest] = text.split('@@');
                    const [customerName, ...taskDescriptionParts] = rest.split(/:(.*)/s);
                    const taskDescription = taskDescriptionParts.join(':');

                    return (
                        <>
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onSelectCustomer({ id: customerId, given_name: customerName.split(' ')[0] });
                                }}
                                className="text-cyan-600 dark:text-cyan-400 hover:underline font-medium"
                            >
                                {customerName}:
                            </button>
                            <span className="ml-1">{taskDescription}</span>
                        </>
                    );
                }
                return text;
            };
             const renderDueDate = (item) => {
                if (!item.dueDate) return null;
                const today = new Date();
                today.setHours(0, 0, 0, 0); // Set to start of day for accurate comparison
                const dueDate = new Date(item.dueDate);
                 // Adjust for timezone offset
                const userTimezoneOffset = dueDate.getTimezoneOffset() * 60000;
                const adjustedDueDate = new Date(dueDate.getTime() + userTimezoneOffset);
                const isOverdue = adjustedDueDate < today && !item.completed;

                return (
                    <span className={`text-sm ml-auto mr-2 ${isOverdue ? 'text-red-500 font-semibold' : 'text-gray-500 dark:text-gray-400'}`}>
                        Due: {formatSimpleDate(item.dueDate)}
                    </span>
                );
            };

            const renderTaskList = (items) => (
                <ul className="space-y-2">
                    {items.map(item => (
                        <li key={item.id} className="flex items-center space-x-3 group">
                            <input 
                                type="checkbox" 
                                checked={item.completed} 
                                onChange={(e) => onUpdate(userId, item.id, e.target.checked)}
                                className="h-5 w-5 text-cyan-600 border-gray-300 rounded focus:ring-cyan-500 dark:bg-gray-600 dark:border-gray-500"
                            />
                            <span className={`flex-grow dark:text-gray-200 ${item.completed ? 'line-through text-gray-400 dark:text-gray-500' : ''}`}>
                                {renderTaskText(item)}
                            </span>
                            {renderDueDate(item)}
                        </li>
                    ))}
                </ul>
            );

            return (
                 <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
                    <button onClick={() => onNavigate('checklist')} className="w-full text-left">
                        <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-4 hover:text-cyan-600 dark:hover:text-cyan-400 transition-colors">Urgent Tasks</h3>
                    </button>
                    <div className="space-y-4">
                        {categorizedTasks.overdue.length > 0 && (
                            <div>
                                <h4 className="text-md font-semibold text-red-500 dark:text-red-400 mb-2">Overdue</h4>
                                {renderTaskList(categorizedTasks.overdue)}
                            </div>
                        )}
                         {categorizedTasks.dueToday.length > 0 && (
                            <div>
                                <h4 className="text-md font-semibold text-gray-500 dark:text-gray-400 mb-2">Due Today</h4>
                                {renderTaskList(categorizedTasks.dueToday)}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        function CalendarWidget({ calendarId }) {
            const calendarSrc = `https://calendar.google.com/calendar/embed?src=${encodeURIComponent(calendarId)}&mode=AGENDA&ctz=America/Los_Angeles`;
            return (
                <div className="bg-white dark:bg-gray-800 rounded-lg shadow p-4">
                    <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200 mb-4">Upcoming Events</h3>
                    <iframe 
                        src={calendarSrc} 
                        style={{ borderWidth: 0 }} 
                        width="100%" 
                        height="400" 
                        frameBorder="0" 
                        scrolling="no"
                    ></iframe>
                </div>
            );
        }

        function DashboardWidget({ widget, allCustomers, allOrders, groupsMap, segmentsMap, onWidgetClick }) {
            const filteredData = useMemo(() => {
                let data = widget.reportType === 'customer' ? (allCustomers || []) : (allOrders || []);
                
                return data.filter(row => {
                    return Object.entries(widget.filters || {}).every(([key, filterConfig]) => {
                        if (!filterConfig || (filterConfig.values?.size === 0 && !filterConfig.date_range && !filterConfig.relative_date_range && filterConfig.excludedValues?.size === 0 && !filterConfig.excluded_date_range)) return true;
                        
                        const field = widget.fields.find(c => c.key === key);
                        if (!field) return true;
                        
                        let value;
                        if (widget.reportType === 'customer' && field.key === 'groups') {
                            const customer = row;
                            const groupNames = (customer.group_ids || []).map(id => groupsMap.get(id));
                            const segmentNames = (customer.segment_ids || []).map(id => segmentsMap.get(id));
                            const customerGroups = new Set([...groupNames, ...segmentNames].filter(Boolean));

                            const included = filterConfig.values && filterConfig.values.size > 0;
                            const excluded = filterConfig.excludedValues && filterConfig.excludedValues.size > 0;

                            if (!included && !excluded) return true;

                            let matchesIncluded = !included;
                            if (included) {
                                if (filterConfig.mode === 'all') {
                                    matchesIncluded = Array.from(filterConfig.values).every(v => customerGroups.has(v));
                                } else {
                                    matchesIncluded = Array.from(filterConfig.values).some(v => customerGroups.has(v));
                                }
                            }

                            let matchesExcluded = false;
                            if (excluded) {
                                matchesExcluded = Array.from(filterConfig.excludedValues).some(v => customerGroups.has(v));
                            }
                            
                            return matchesIncluded && !matchesExcluded;
                        }

                        value = getNestedValue(row, field.path);
                        if (field.path && (field.path.includes('created_at') || field.path.includes('purchase_date') || field.key === 'last_sms_contact')) {
                            const rowDate = value ? new Date(value) : null;
                            
                            let includedRange = filterConfig.date_range;
                            if (filterConfig.relative_date_range) {
                                includedRange = getRelativeDateRange(filterConfig.relative_date_range);
                            }
                            
                            const startDate = includedRange?.startDate ? new Date(includedRange.startDate) : null;
                            const endDate = includedRange?.endDate ? new Date(includedRange.endDate) : null;
                            
                            const matchesDateRange = (!startDate || (rowDate && rowDate >= startDate)) && (!endDate || (rowDate && rowDate <= endDate));
                            
                            let isExcluded = false;
                            if (filterConfig.excluded_date_range || filterConfig.excluded_relative_date_range) {
                                let excludedRange = filterConfig.excluded_date_range;
                                if (filterConfig.excluded_relative_date_range) {
                                    excludedRange = getRelativeDateRange(filterConfig.excluded_relative_date_range);
                                }
                                const excludedStartDate = excludedRange?.startDate ? new Date(excludedRange.startDate) : null;
                                const excludedEndDate = excludedRange?.endDate ? new Date(excludedRange.endDate) : null;
                                isExcluded = rowDate && (!excludedStartDate || rowDate >= excludedStartDate) && (!excludedEndDate || rowDate <= excludedEndDate);
                            }
                            
                            return matchesDateRange && !isExcluded;

                        }
                        
                        const rowValue = (value || 'N/A').toString().toLowerCase();

                        const valuesToMatch = Array.from(filterConfig.values || []).map(v => String(v).toLowerCase());
                        const excludedValues = Array.from(filterConfig.excludedValues || []).map(v => String(v).toLowerCase());

                        const matchesIncluded = valuesToMatch.length === 0 || valuesToMatch.some(v => rowValue === v);
                        const matchesExcluded = excludedValues.length > 0 && excludedValues.some(v => rowValue === v);
                        
                        return matchesIncluded && !matchesExcluded;
                    });
                });
            }, [widget, allCustomers, allOrders, groupsMap, segmentsMap]);

            const countToDisplay = useMemo(() => {
                if (widget.reportType === 'item') {
                    return filteredData.length;
                }
                const uniqueCustomerIds = new Set(filteredData.map(item => item.customer_id).filter(id => id));
                return widget.reportType === 'customer' ? filteredData.length : uniqueCustomerIds.size;
            }, [filteredData, widget.reportType]);

            const percentage = useMemo(() => {
                const total = widget.reportType === 'customer' ? allCustomers.length : allOrders.length;
                if (total === 0) return 0;
                return (countToDisplay / total * 100).toFixed(1);
            }, [countToDisplay, widget.reportType, allCustomers, allOrders]);
            
            let borderColor = 'border-transparent';
            let textColor = 'text-cyan-600 dark:text-cyan-400';

            if (widget.targetMin != null && widget.targetMax != null) {
                const count = countToDisplay;
                let min = widget.targetMin;
                let max = widget.targetMax;

                if (widget.targetType === 'percentage') {
                    const total = widget.reportType === 'item' ? allOrders.length : allCustomers.length;
                    min = (widget.targetMin / 100) * total;
                    max = (widget.targetMax / 100) * total;
                }

                const below = count < min;
                const above = count > max;

                if (widget.reverseRange) {
                    if (below) {
                        borderColor = 'border-green-500';
                        textColor = 'text-green-600 dark:text-green-400';
                    } else if (above) {
                        borderColor = 'border-red-500';
                        textColor = 'text-red-600 dark:text-red-400';
                    } else {
                        borderColor = 'border-yellow-500';
                        textColor = 'text-yellow-600 dark:text-yellow-400';
                    }
                } else {
                     if (below) {
                        borderColor = 'border-red-500';
                        textColor = 'text-red-600 dark:text-red-400';
                    } else if (above) {
                        borderColor = 'border-green-500';
                        textColor = 'text-green-600 dark:text-green-400';
                    } else {
                        borderColor = 'border-yellow-500';
                        textColor = 'text-yellow-600 dark:text-yellow-400';
                    }
                }
            }

            const getTargetDifference = () => {
                if (widget.targetMin != null && widget.targetMax != null) {
                    const count = countToDisplay;
                    
                    if (widget.targetType === 'percentage') {
                        const total = widget.reportType === 'item' ? allOrders.length : allCustomers.length;
                        const currentPercentage = total > 0 ? (count / total) * 100 : 0;
                        if (currentPercentage < widget.targetMin) return `${(currentPercentage - widget.targetMin).toFixed(1)}%`;
                        if (currentPercentage > widget.targetMax) return `+${(currentPercentage - widget.targetMax).toFixed(1)}%`;
                        return 0;
                    } else {
                        if (count < widget.targetMin) return count - widget.targetMin;
                        if (count > widget.targetMax) return `+${count - widget.targetMax}`;
                        return 0;
                    }
                }
                return null;
            };
    
            const targetDifference = getTargetDifference();

            return (
                <button onClick={() => onWidgetClick(widget)} className={`p-6 bg-white dark:bg-gray-800 rounded-lg shadow hover:bg-cyan-50 dark:hover:bg-gray-700 text-left transition flex flex-col justify-between border-4 ${borderColor}`}>
                    <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200">{widget.name}</h3>
                    <div className="flex justify-between items-end mt-4">
                        <div>
                            <p className={`text-5xl font-bold ${textColor}`}>{countToDisplay}</p>
                            <p className="text-gray-500 dark:text-gray-400">
                                {widget.reportType === 'customer' ? `Customers (${percentage}%)` : `Items (${percentage}%)`}
                            </p>
                        </div>
                        {targetDifference !== null && (
                            <div className={`flex items-center text-lg font-semibold ${textColor}`}>
                                <span></span>
                                {targetDifference !== 0 && (
                                    <span className="ml-1">{targetDifference}</span>
                                )}
                            </div>
                        )}
                    </div>
                </button>
            );
        }
        
        function DirectoryPage({ allCustomers, onSelectCustomer, onBack }) {
            const [searchTerm, setSearchTerm] = useState('');
            const filteredCustomers = useMemo(() => {
                const lowercasedTerm = searchTerm.toLowerCase();
                if (!lowercasedTerm) return allCustomers;
                return allCustomers.filter(c => 
                    (c.given_name && c.given_name.toLowerCase().includes(lowercasedTerm)) ||
                    (c.family_name && c.family_name.toLowerCase().includes(lowercasedTerm)) ||
                    (c.email_address && c.email_address.toLowerCase().includes(lowercasedTerm)) ||
                    (c.phone_number && c.phone_number.includes(searchTerm))
                );
            }, [searchTerm, allCustomers]);

            return (
                <div className="p-8">
                    <button onClick={onBack} className="mb-6 text-cyan-600 dark:text-cyan-400 hover:text-cyan-800 dark:hover:text-cyan-200"> &larr; Back to Dashboard</button>
                    <h2 className="text-4xl font-bold text-gray-800 dark:text-gray-200">Customer Directory</h2>
                    <div className="mt-4">
                        <input type="text" value={searchTerm} onChange={e => setSearchTerm(e.target.value)} placeholder="Filter customers..." className="w-full max-w-lg px-4 py-2 border rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"/>
                    </div>
                    <div className="mt-8 bg-white dark:bg-gray-800 rounded-lg shadow overflow-hidden">
                        <ul className="divide-y divide-gray-200 dark:divide-gray-700">
                            {filteredCustomers.map(customer => (
                                <li key={customer.id}>
                                    <button onClick={() => onSelectCustomer(customer)} className="w-full text-left p-4 hover:bg-gray-50 dark:hover:bg-gray-700">
                                        <p className="font-semibold text-gray-800 dark:text-gray-200">{customer.given_name} {customer.family_name}</p>
                                        <p className="text-sm text-gray-500 dark:text-gray-400">{customer.email_address || 'No email'}</p>
                                    </button>
                                </li>
                            ))}
                        </ul>
                    </div>
                </div>
            );
        }

        function ReportsPage({ allCustomers, allOrders, groupsMap, segmentsMap, customAttrDefs, onSelectCustomer, onBack, savedReports, onSaveReport, onUpdateReport, onDeleteReport, initialReport, onInitialReportLoaded, totalCustomers, isAdmin }) {
            const getCustomerReportFields = useCallback(() => {
                const standardFields = [
                    { key: 'customer_id', label: 'Customer ID', visible: false, path: ['id'] },
                    { key: 'given_name', label: 'First Name', visible: true, path: ['given_name'] },
                    { key: 'family_name', label: 'Last Name', visible: true, path: ['family_name'] },
                    { key: 'email_address', label: 'Email', visible: true, path: ['email_address'] },
                    { key: 'phone_number', label: 'Phone', visible: true, path: ['phone_number'] },
                    { key: 'created_at', label: 'Customer Since', visible: true, path: ['created_at'] },
                    { key: 'groups', label: 'Groups & Segments', visible: true, path: [] },
                    { key: 'last_sms_contact', label: 'Last Contact Date', visible: true, path: ['last_sms_contact'] },
                    { key: 'note', label: 'Notes', visible: true, path: ['note'] },
                ];
                return [...standardFields];
            }, []);

            const getItemReportFields = useCallback(() => {
                return [
                    { key: 'customer_id', label: 'Customer ID', visible: false, path: ['customer_id'] },
                    { key: 'given_name', label: 'First Name', visible: true, path: ['customer', 'given_name'] },
                    { key: 'family_name', label: 'Last Name', visible: true, path: ['customer', 'family_name'] },
                    { key: 'email_address', label: 'Email', visible: true, path: ['customer', 'email_address'] },
                    { key: 'phone_number', label: 'Phone', visible: true, path: ['customer', 'phone_number'] },
                    { key: 'line_item_name', label: 'Line Item', visible: true, path: ['line_item_name'] },
                    { key: 'quantity', label: 'Quantity', visible: true, path: ['quantity'] },
                    { key: 'purchase_date', label: 'Purchase Date', visible: true, path: ['purchase_date'] },
                    { key: 'last_sms_contact', label: 'Last Contact Date', visible: true, path: ['customer', 'last_sms_contact'] },
                    { key: 'note', label: 'Notes', visible: true, path: ['customer', 'note'] },
                ];
            }, []);

            const [reportType, setReportType] = useState(initialReport?.reportType || 'customer');
            const [fields, setFields] = useState(initialReport?.fields || (initialReport?.reportType === 'item' ? getItemReportFields() : getCustomerReportFields()));
            const [fieldFilters, setFieldFilters] = useState(initialReport?.filters || {});
            const [sortConfig, setSortConfig] = useState(initialReport?.sortConfig || { key: 'given_name', direction: 'ascending' });
            const [activeFieldFilterPopup, setActiveFieldFilterPopup] = useState(null);
            const [isSaveModalOpen, setIsSaveModalOpen] = useState(false);
            const [refreshReportTrigger, setRefreshReportTrigger] = useState(0);
            const [isSidebarOpen, setIsSidebarOpen] = useState(true);

            const visibleFields = useMemo(() => fields.filter(c => c.visible), [fields]);
            
            const customerMap = useMemo(() => {
                const map = new Map();
                (allCustomers || []).forEach(c => map.set(c.id, c));
                return map;
            }, [allCustomers]);
            
            const enrichedOrders = useMemo(() => {
                return (allOrders || []).map(order => ({
                    ...order,
                    customer: customerMap.get(order.customer_id) || {}
                }));
            }, [allOrders, customerMap, refreshReportTrigger]);

            const dataToDisplay = reportType === 'customer' ? (allCustomers || []) : enrichedOrders;

            const filteredAndSortedData = useMemo(() => {
                let data = [...dataToDisplay];
                
                data = data.filter(row => {
                    return Object.entries(fieldFilters).every(([key, filterConfig]) => {
                        if (!filterConfig) return true;
                        
                        const field = fields.find(c => c.key === key);
                        if (!field) return true;
                        
                        if (field.key === 'groups') {
                            const customer = row;
                            const groupNames = (customer.group_ids || []).map(id => groupsMap.get(id));
                            const segmentNames = (customer.segment_ids || []).map(id => segmentsMap.get(id));
                            const customerGroups = new Set([...groupNames, ...segmentNames].filter(Boolean));

                            const included = filterConfig.values && filterConfig.values.size > 0;
                            const excluded = filterConfig.excludedValues && filterConfig.excludedValues.size > 0;

                            if (!included && !excluded) return true;

                            let matchesIncluded = !included;
                            if (included) {
                                matchesIncluded = filterConfig.mode === 'all' 
                                    ? Array.from(filterConfig.values).every(v => customerGroups.has(v))
                                    : Array.from(filterConfig.values).some(v => customerGroups.has(v));
                            }

                            let matchesExcluded = excluded ? Array.from(filterConfig.excludedValues).some(v => customerGroups.has(v)) : false;
                            
                            return matchesIncluded && !matchesExcluded;
                        }

                        let value = getNestedValue(row, field.path);
                        if (field.path && (field.path.includes('created_at') || field.path.includes('purchase_date') || field.key === 'last_sms_contact')) {
                            const rowDate = value ? new Date(value) : null;
                            
                            let includedRange = filterConfig.date_range;
                            if (filterConfig.relative_date_range) {
                                includedRange = getRelativeDateRange(filterConfig.relative_date_range);
                            }
                            
                            const startDate = includedRange?.startDate ? new Date(includedRange.startDate) : null;
                            const endDate = includedRange?.endDate ? new Date(includedRange.endDate) : null;

                            const matchesDateRange = (!startDate || rowDate >= startDate) && (!endDate || rowDate <= endDate);
                            
                            let isExcluded = false;
                            if (filterConfig.excluded_date_range || filterConfig.excluded_relative_date_range) {
                                let excludedRange = filterConfig.excluded_date_range;
                                if (filterConfig.excluded_relative_date_range) {
                                    excludedRange = getRelativeDateRange(filterConfig.excluded_relative_date_range);
                                }
                                const excludedStartDate = excludedRange.startDate ? new Date(excludedRange.startDate) : null;
                                const excludedEndDate = excludedRange.endDate ? new Date(excludedRange.endDate) : null;
                                isExcluded = rowDate && (!excludedStartDate || rowDate >= excludedStartDate) && (!excludedEndDate || rowDate <= excludedEndDate);
                            }
                            
                            return matchesDateRange && !isExcluded;
                        }
                        
                        const rowValue = (value || 'N/A').toString().toLowerCase();

                        const valuesToMatch = Array.from(filterConfig.values || []);
                        const excludedValues = Array.from(filterConfig.excludedValues || []);
                        
                        const isExactMatchField = ['line_item_name'].includes(field.key);
                        
                        let matchesValue = valuesToMatch.length === 0 || valuesToMatch.some(v => 
                            isExactMatchField ? rowValue === String(v).toLowerCase() : rowValue.includes(String(v).toLowerCase())
                        );

                        let matchesExcluded = excludedValues.length > 0 && excludedValues.some(v => 
                            isExactMatchField ? rowValue === String(v).toLowerCase() : rowValue.includes(String(v).toLowerCase())
                        );

                        return matchesValue && !matchesExcluded;
                    });
                });

                if (sortConfig.key) {
                    data.sort((a, b) => {
                        const field = fields.find(c => c.key === sortConfig.key);
                        if (!field) return 0;
                        let aVal, bVal;
                        
                        if (field.key === 'groups') {
                            const aGroups = [...(a.group_ids || []).map(id => groupsMap.get(id)), ...(a.segment_ids || []).map(id => segmentsMap.get(id))].join('');
                            const bGroups = [...(b.group_ids || []).map(id => groupsMap.get(id)), ...(b.segment_ids || []).map(id => segmentsMap.get(id))].join('');
                            aVal = aGroups; bVal = bGroups;
                        } else if (field.key === 'quantity') {
                            aVal = getNestedValue(a, field.path) || 0;
                            bVal = getNestedValue(b, field.path) || 0;
                        } else if (field.key === 'purchase_date' || field.key === 'created_at' || field.key === 'last_sms_contact') {
                            const aDate = getNestedValue(a, field.path);
                            const bDate = getNestedValue(b, field.path);
                            aVal = aDate ? new Date(aDate) : new Date(0);
                            bVal = bDate ? new Date(bDate) : new Date(0);
                        } else {
                            aVal = getNestedValue(a, field.path) || ''; 
                            bVal = getNestedValue(b, field.path) || '';
                        }
                        
                        if (typeof aVal === 'string' && typeof bVal === 'string') {
                            return sortConfig.direction === 'ascending' ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
                        }
                        if (aVal < bVal) return sortConfig.direction === 'ascending' ? -1 : 1;
                        if (aVal > bVal) return sortConfig.direction === 'ascending' ? 1 : -1;
                        return 0;
                    });
                }
                return data;
            }, [dataToDisplay, fieldFilters, sortConfig, fields, groupsMap, segmentsMap, refreshReportTrigger]);
            
            const handleModalSave = (name, isWidget, isShared, targetMin, targetMax, targetType, reverseRange) => {
                const report = { name, filters: fieldFilters, sortConfig, fields, isWidget, isShared, reportType, targetMin: parseInt(targetMin, 10) || null, targetMax: parseInt(targetMax, 10) || null, targetType, reverseRange };
                onSaveReport(report, isWidget, isShared);
                setIsSaveModalOpen(false);
            };
            
            const handleLoadReport = (report) => {
                const filtersWithSets = Object.entries(report.filters).reduce((acc, [key, val]) => {
                    acc[key] = { ...val, values: new Set(val.values), excludedValues: new Set(val.excludedValues) };
                    return acc;
                }, {});
                setFieldFilters(filtersWithSets);
                setSortConfig(report.sortConfig || { key: 'given_name', direction: 'ascending' });
                setReportType(report.reportType || 'customer');
                setFields(report.fields || (report.reportType === 'item' ? getItemReportFields() : getCustomerReportFields()));
            };
            
            const handleReportTypeChange = (type) => {
                setReportType(type);
                setFieldFilters({});
                setSortConfig({ key: 'given_name', direction: 'ascending' });
                if (type === 'customer') {
                    setFields(getCustomerReportFields());
                } else {
                    setFields(getItemReportFields());
                }
            };
            
            useEffect(() => {
                if (initialReport) {
                    handleLoadReport(initialReport);
                    onInitialReportLoaded();
                }
            }, [initialReport, onInitialReportLoaded, getCustomerReportFields, getItemReportFields]);
            
            const percentage = totalCustomers > 0 ? (filteredAndSortedData.length / totalCustomers * 100).toFixed(1) : 0;
            const itemReportFields = getItemReportFields();

            const handleLocalRefresh = () => {
                setRefreshReportTrigger(prev => prev + 1);
            };

            return (
                <div className="flex h-full">
                    {isSidebarOpen && (
                        <ReportsSidebar 
                            fields={fields} 
                            setFields={setFields}
                            savedReports={savedReports}
                            onLoadReport={handleLoadReport}
                            onSaveReportClick={() => setIsSaveModalOpen(true)}
                            onUpdateReport={onUpdateReport}
                            onDeleteReport={onDeleteReport}
                            isAdmin={isAdmin}
                        />
                    )}
                    <div className="flex-1 p-8 overflow-y-auto relative">
                        <button 
                            onClick={() => setIsSidebarOpen(!isSidebarOpen)}
                            className="absolute top-8 left-0 z-10 p-1 bg-white dark:bg-gray-900 rounded-r-md shadow-lg hover:bg-gray-100 dark:hover:bg-gray-700 transition-colors"
                            title={isSidebarOpen ? "Hide Sidebar" : "Show Sidebar"}
                        >
                            <svg className={`w-6 h-6 text-gray-600 dark:text-gray-300 transform transition-transform ${isSidebarOpen ? '' : 'rotate-180'}`} fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 19l-7-7 7-7"></path></svg>
                        </button>
                        <div className="flex justify-between items-center mb-6">
                            <button onClick={onBack} className="text-cyan-600 dark:text-cyan-400 hover:text-cyan-800 dark:hover:text-cyan-200"> &larr; Back to Dashboard</button>
                            <div className="flex space-x-2 rounded-md shadow-sm" role="group">
                                <button type="button" onClick={() => handleReportTypeChange('customer')} className={`px-4 py-2 text-sm font-medium ${reportType === 'customer' ? 'bg-cyan-600 text-white' : 'bg-white text-gray-900 border border-gray-200'} rounded-l-md hover:bg-gray-100 dark:bg-gray-700 dark:border-gray-600 dark:text-white dark:hover:text-white dark:hover:bg-gray-600`}>Customer Report</button>
                                <button type="button" onClick={() => handleReportTypeChange('item')} className={`px-4 py-2 text-sm font-medium ${reportType === 'item' ? 'bg-cyan-600 text-white' : 'bg-white text-gray-900 border border-gray-200'} rounded-r-md hover:bg-gray-100 dark:bg-gray-700 dark:border-gray-600 dark:text-white dark:hover:text-white dark:hover:bg-gray-600`}>Item Report</button>
                            </div>
                            <button onClick={handleLocalRefresh} className="px-4 py-2 bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 rounded-md text-sm font-medium hover:bg-gray-300 dark:hover:bg-gray-600 transition">Refresh Report</button>
                            <span className="text-gray-600 dark:text-gray-300 font-semibold">{filteredAndSortedData.length} {reportType === 'customer' ? 'Customers' : 'Items'}</span>
                        </div>
                        <h2 className="text-4xl font-bold text-gray-800 dark:text-gray-200">{reportType === 'customer' ? 'Customer Report' : 'Item Report'}</h2>
                        <div className="mt-8 bg-white dark:bg-gray-800 rounded-lg shadow overflow-x-auto">
                            <table className="w-full text-sm text-left text-gray-500 dark:text-gray-400">
                                <thead className="text-xs text-gray-700 dark:text-gray-400 uppercase bg-gray-50 dark:bg-gray-700">
                                    <tr>{visibleFields.map(field => <SortableHeader key={field.key} field={field} setSortConfig={setSortConfig} sortConfig={sortConfig} setActiveFilterPopup={setActiveFieldFilterPopup} filters={fieldFilters} />)}</tr>
                                </thead>
                                <tbody>
                                    {filteredAndSortedData.length === 0 && <tr><td colSpan={visibleFields.length} className="text-center p-4 text-gray-500 dark:text-gray-400">No customers match the current filters.</td></tr>}
                                    {filteredAndSortedData.map(row => (
                                        <tr key={reportType === 'customer' ? row.id : row.item_uid} className="bg-white dark:bg-gray-800 border-b dark:border-gray-700 hover:bg-gray-50 dark:hover:bg-gray-600">
                                            {visibleFields.map(field => {
                                                let cellContent = 'N/A';
                                                let cellClassName = "px-6 py-4 whitespace-nowrap";
                                                
                                                if (reportType === 'customer') {
                                                    const customer = row;
                                                    if (field.key === 'given_name') {
                                                        cellContent = <button onClick={() => onSelectCustomer(customer)} className="text-cyan-600 dark:text-cyan-400 hover:underline font-medium whitespace-nowrap">{customer.given_name || ''}</button>;
                                                    } else if (field.key === 'groups') {
                                                        const groupNames = (customer.group_ids || []).map(id => ({ name: groupsMap.get(id) || id, color: 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300' }));
                                                        const segmentNames = (customer.segment_ids || []).map(id => ({ name: segmentsMap.get(id) || id, color: 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300' }));
                                                        cellContent = <div className="flex flex-wrap gap-1">{[...groupNames, ...segmentNames].map((pill, i) => <Pill key={i} text={pill.name} color={pill.color} />)}</div>;
                                                    } else if (field.key === 'last_sms_contact') {
                                                        cellContent = formatSimpleDate(getNestedValue(customer, field.path));
                                                    } else if (field.key === 'note') {
                                                        cellContent = getNestedValue(customer, field.path) || 'N/A';
                                                        cellClassName = "px-6 py-4 whitespace-normal max-w-xs";
                                                    } else {
                                                        cellContent = getNestedValue(customer, field.path) || 'N/A';
                                                    }
                                                } else { // Item report
                                                    const customer = row.customer;
                                                    const customerExists = customer && Object.keys(customer).length > 0;
                                                    
                                                    if (field.key === 'given_name') {
                                                        cellContent = customerExists ? <button onClick={() => onSelectCustomer(customer)} className="text-cyan-600 dark:text-cyan-400 hover:underline font-medium whitespace-nowrap">{customer.given_name || ''}</button> : 'N/A';
                                                    } else if (field.key === 'note') {
                                                        cellContent = customerExists ? getNestedValue(row, field.path) || 'N/A' : 'N/A';
                                                        cellClassName = "px-6 py-4 whitespace-normal max-w-xs";
                                                    } else {
                                                        cellContent = getNestedValue(row, field.path) || 'N/A';
                                                    }
                                                }

                                                return <td key={field.key} className={cellClassName}>{cellContent}</td>;
                                            })}
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </div>
                    {activeFieldFilterPopup && <FilterPopup field={activeFieldFilterPopup} dataSource={dataToDisplay} filters={fieldFilters} setFilters={setFieldFilters} onClose={() => setActiveFieldFilterPopup(null)} getNestedValue={getNestedValue} groupsMap={groupsMap} segmentsMap={segmentsMap} />}
                    {isSaveModalOpen && <SaveReportModal onSave={handleModalSave} onCancel={() => setIsSaveModalOpen(false)} isAdmin={isAdmin} />}
                </div>
            );
        }
        
        // --- Standalone Components ---
        
        const SortableHeader = ({ field, setSortConfig, sortConfig, setActiveFilterPopup, filters }) => {
            const isSorted = sortConfig.key === field.key;
            const isFiltered = filters[field.key] && (filters[field.key].values?.size > 0 || filters[field.key].date_range || filters[field.key].relative_date_range);
            
            let headerClassName = "px-6 py-3";
            if (field.key === 'note') headerClassName += " max-w-xs";
            
            return (
                <th scope="col" className={headerClassName}>
                    <div className="flex items-center">
                        <button onClick={() => setSortConfig({ key: field.key, direction: sortConfig.key === field.key && sortConfig.direction === 'ascending' ? 'descending' : 'ascending' })} className="uppercase font-bold">
                            {field.label}
                        </button>
                        {isSorted && (sortConfig.direction === 'ascending' ? <span className="ml-1"></span> : <span className="ml-1"></span>)}
                        <button onClick={() => setActiveFilterPopup(field)} className="ml-2 text-gray-400 hover:text-gray-700 dark:hover:text-white">
                            <svg className={`w-4 h-4 ${isFiltered ? 'text-cyan-600 dark:text-cyan-400' : ''}`} fill="currentColor" viewBox="0 0 20 20"><path fillRule="evenodd" d="M3 3a1 1 0 011-1h12a1 1 0 011 1v3a1 1 0 01-.293.707L12 11.414V15a1 1 0 01-.293.707l-2 2A1 1 0 018 17v-5.586L3.293 6.707A1 1 0 013 6V3z" clipRule="evenodd"></path></svg>
                        </button>
                    </div>
                </th>
            );
        };

        function FilterPopup({ field, dataSource, filters, setFilters, onClose, getNestedValue, groupsMap, segmentsMap }) {
            const isDateField = field.key === 'created_at' || field.key === 'purchase_date' || field.key === 'last_sms_contact';

            const getFieldValues = () => {
                const values = new Set();
                dataSource.forEach(row => {
                    let value;
                    if (field.key === 'groups') {
                        (row.group_ids || []).forEach(id => { if(groupsMap.has(id)) values.add(groupsMap.get(id))});
                        (row.segment_ids || []).forEach(id => { if(segmentsMap.has(id)) values.add(segmentsMap.get(id))});
                    } else {
                        value = getNestedValue(row, field.path);
                        if (value !== undefined && value !== null && value !== '') {
                            if (isDateField) {
                                value = formatSimpleDate(value);
                            }
                            values.add(value.toString());
                        } else {
                            values.add('N/A');
                        }
                    }
                });
                return Array.from(values).sort((a,b) => String(a).localeCompare(String(b), undefined, {numeric: true}));
            };
            
            const [uniqueValues] = useState(getFieldValues);
            const [checkedValues, setCheckedValues] = useState(filters[field.key]?.values || new Set());
            const [excludedValues, setExcludedValues] = useState(filters[field.key]?.excludedValues || new Set());
            
            const [dateMode, setDateMode] = useState(filters[field.key]?.date_range || filters[field.key]?.excluded_date_range ? 'custom' : (filters[field.key]?.relative_date_range || filters[field.key]?.excluded_relative_date_range ? 'relative' : 'custom'));

            const [dateRange, setDateRange] = useState(filters[field.key]?.date_range || { startDate: '', endDate: '' });
            const [excludedDateRange, setExcludedDateRange] = useState(filters[field.key]?.excluded_date_range || { startDate: '', endDate: '' });
            
            const initialRelativeDate = filters[field.key]?.relative_date_range || '';
            const [relativePeriod, setRelativePeriod] = useState(initialRelativeDate.split(' ')[0] || '');
            const [relativeUnit, setRelativeUnit] = useState(initialRelativeDate.split(' ')[1] || '');

            const initialExcludedRelativeDate = filters[field.key]?.excluded_relative_date_range || '';
            const [excludedRelativePeriod, setExcludedRelativePeriod] = useState(initialExcludedRelativeDate.split(' ')[0] || '');
            const [excludedRelativeUnit, setExcludedRelativeUnit] = useState(initialExcludedRelativeDate.split(' ')[1] || '');
            
            const [searchTerm, setSearchTerm] = useState('');
            const [matchMode, setMatchMode] = useState(filters[field.key]?.mode || 'any');

            const handleCheck = (value, isExcluded) => {
                const currentSet = isExcluded ? excludedValues : checkedValues;
                const setter = isExcluded ? setExcludedValues : setCheckedValues;
                const newChecked = new Set(currentSet);
                if (newChecked.has(value)) newChecked.delete(value);
                else newChecked.add(value);
                setter(newChecked);
            };
            
            const handleDateRangeChange = (e, rangeType) => {
                const { name, value } = e.target;
                if (rangeType === 'included') {
                    setDateRange(prev => ({ ...prev, [name]: value }));
                } else {
                    setExcludedDateRange(prev => ({ ...prev, [name]: value }));
                }
            };
            
            const handleRelativeDateChange = (e, rangeType) => {
                const { name, value } = e.target;
                if (rangeType === 'included') {
                    if (name === 'period') {
                        setRelativePeriod(value);
                    } else {
                        setRelativeUnit(value);
                    }
                    setDateRange({ startDate: '', endDate: '' });
                } else {
                    if (name === 'period') {
                        setExcludedRelativePeriod(value);
                    } else {
                        setExcludedRelativeUnit(value);
                    }
                    setExcludedDateRange({ startDate: '', endDate: '' });
                }
            };

            const handleApply = () => {
                const newFilter = {
                    values: checkedValues, 
                    excludedValues: excludedValues, 
                    mode: matchMode
                };
                if (isDateField) {
                    if (dateMode === 'relative') {
                        if (relativePeriod && relativeUnit) {
                            newFilter.relative_date_range = `${relativePeriod} ${relativeUnit}`;
                        }
                        if (excludedRelativePeriod && excludedRelativeUnit) {
                            newFilter.excluded_relative_date_range = `${excludedRelativePeriod} ${excludedRelativeUnit}`;
                        }
                    } else {
                        if (dateRange.startDate || dateRange.endDate) {
                            newFilter.date_range = dateRange;
                        }
                        if (excludedDateRange.startDate || excludedDateRange.endDate) {
                            newFilter.excluded_date_range = excludedDateRange;
                        }
                    }
                }
                setFilters(prev => ({ ...prev, [field.key]: newFilter }));
                onClose();
            };
            
            const handleRemoveFilter = () => {
                const newFilters = { ...filters };
                delete newFilters[field.key];
                setFilters(newFilters);
                onClose();
            };
            
            const sortedAndFilteredValues = useMemo(() => {
                const searched = uniqueValues.filter(v =>
                    String(v).toLowerCase().includes(searchTerm.toLowerCase())
                );
                
                const checked = [];
                const unchecked = [];

                searched.forEach(value => {
                    if (checkedValues.has(value) || excludedValues.has(value)) {
                        checked.push(value);
                    } else {
                        unchecked.push(value);
                    }
                });

                return [...checked, ...unchecked];
            }, [searchTerm, uniqueValues, checkedValues, excludedValues]);


            return (
                <div className="fixed inset-0 bg-black bg-opacity-25 flex items-center justify-center z-30" onClick={onClose}>
                    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-4 w-full max-w-md" onClick={e => e.stopPropagation()}>
                        <div className="flex justify-between items-center">
                            <h3 className="font-bold text-lg dark:text-gray-200">Filter by {field.label}</h3>
                            <button onClick={onClose} className="text-gray-400 hover:text-gray-600 dark:hover:text-white">&times;</button>
                        </div>
                        
                        {field.key === 'groups' && (
                            <div className="mt-4 border-b dark:border-gray-700 pb-4">
                                <h4 className="text-sm font-semibold mb-2 dark:text-gray-300">Match Type</h4>
                                <div className="flex space-x-4 text-sm dark:text-gray-300">
                                    <label className="flex items-center">
                                        <input type="radio" name="match-mode" value="any" checked={matchMode === 'any'} onChange={(e) => setMatchMode(e.target.value)} className="mr-1"/>
                                        Match Any (OR)
                                    </label>
                                    <label className="flex items-center">
                                        <input type="radio" name="match-mode" value="all" checked={matchMode === 'all'} onChange={(e) => setMatchMode(e.target.value)} className="mr-1"/>
                                        Match All (AND)
                                    </label>
                                </div>
                            </div>
                        )}

                        <div className="mt-4">
                            {isDateField ? (
                                <div className="grid grid-cols-2 gap-4">
                                    <div>
                                        <h4 className="text-sm font-semibold mb-2 dark:text-gray-300">Match These</h4>
                                        <select value={dateMode} onChange={(e) => setDateMode(e.target.value)} className="w-full px-2 py-1 border rounded-md text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white mb-2">
                                            <option value="relative">Relative Range</option>
                                            <option value="custom">Custom Range</option>
                                        </select>
                                        { dateMode === 'relative' ? (
                                            <div className="flex space-x-2">
                                                <select name="period" value={relativePeriod} onChange={(e) => handleRelativeDateChange(e, 'included')} className="w-1/2 px-2 py-1 border rounded-md text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                                                    <option value="">-</option>
                                                    <option value="This">This</option>
                                                    <option value="Last">Last</option>
                                                </select>
                                                <select name="unit" value={relativeUnit} onChange={(e) => handleRelativeDateChange(e, 'included')} className="w-1/2 px-2 py-1 border rounded-md text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white" disabled={!relativePeriod}>
                                                    <option value="">-</option>
                                                    <option value="Day">Day</option>
                                                    <option value="Week">Week</option>
                                                    <option value="Month">Month</option>
                                                    <option value="Quarter">Quarter</option>
                                                    <option value="Year">Year</option>
                                                </select>
                                            </div>
                                        ) : (
                                            <>
                                                <input type="date" name="startDate" value={dateRange.startDate} onChange={e => handleDateRangeChange(e, 'included')} className="w-full px-2 py-1 border rounded-md text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white mb-2"/>
                                                <input type="date" name="endDate" value={dateRange.endDate} onChange={e => handleDateRangeChange(e, 'included')} className="w-full px-2 py-1 border rounded-md text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white"/>
                                            </>
                                        )}
                                    </div>
                                    <div>
                                        <h4 className="text-sm font-semibold mb-2 dark:text-gray-300">Do Not Match (NOT)</h4>
                                        <select value={dateMode} onChange={(e) => setDateMode(e.target.value)} className="w-full px-2 py-1 border rounded-md text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white mb-2">
                                            <option value="relative">Relative Range</option>
                                            <option value="custom">Custom Range</option>
                                        </select>
                                        { dateMode === 'relative' ? (
                                            <div className="flex space-x-2">
                                                <select name="period" value={excludedRelativePeriod} onChange={(e) => handleRelativeDateChange(e, 'excluded')} className="w-1/2 px-2 py-1 border rounded-md text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white">
                                                    <option value="">-</option>
                                                    <option value="This">This</option>
                                                    <option value="Last">Last</option>
                                                </select>
                                                <select name="unit" value={excludedRelativeUnit} onChange={(e) => handleRelativeDateChange(e, 'excluded')} className="w-1/2 px-2 py-1 border rounded-md text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white" disabled={!excludedRelativePeriod}>
                                                    <option value="">-</option>
                                                    <option value="Day">Day</option>
                                                    <option value="Week">Week</option>
                                                    <option value="Month">Month</option>
                                                    <option value="Quarter">Quarter</option>
                                                    <option value="Year">Year</option>
                                                </select>
                                            </div>
                                        ) : (
                                            <>
                                                <input type="date" name="startDate" value={excludedDateRange.startDate} onChange={e => handleDateRangeChange(e, 'excluded')} className="w-full px-2 py-1 border rounded-md text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white mb-2"/>
                                                <input type="date" name="endDate" value={excludedDateRange.endDate} onChange={e => handleDateRangeChange(e, 'excluded')} className="w-full px-2 py-1 border rounded-md text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white"/>
                                            </>
                                        )}
                                    </div>
                                </div>
                            ) : (
                                <>
                                    <input type="text" value={searchTerm} onChange={e => setSearchTerm(e.target.value)} placeholder="Search values..." className="w-full px-2 py-1 border rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white mb-2"/>
                                    <div className="grid grid-cols-2 gap-4">
                                        <div>
                                            <h4 className="text-sm font-semibold mb-2 dark:text-gray-300">Match These</h4>
                                            <div className="max-h-40 overflow-y-auto border rounded-md p-2 space-y-1 dark:border-gray-700">
                                                {sortedAndFilteredValues.map(value => (
                                                    <label key={`include-${value}`} className="flex items-center text-sm hover:bg-gray-50 dark:hover:bg-gray-700 rounded p-1 dark:text-gray-300">
                                                        <input type="checkbox" checked={checkedValues.has(value)} onChange={() => handleCheck(value, false)} className="mr-2 h-4 w-4 text-cyan-600 border-gray-300 rounded focus:ring-cyan-500 dark:bg-gray-600 dark:border-gray-500"/>
                                                        <span className="truncate">{value}</span>
                                                    </label>
                                                ))}
                                            </div>
                                        </div>
                                        <div>
                                            <h4 className="text-sm font-semibold mb-2 dark:text-gray-300">Do Not Match (NOT)</h4>
                                            <div className="max-h-40 overflow-y-auto border rounded-md p-2 space-y-1 dark:border-gray-700">
                                                {sortedAndFilteredValues.map(value => (
                                                    <label key={`exclude-${value}`} className="flex items-center text-sm hover:bg-gray-50 dark:hover:bg-gray-700 rounded p-1 dark:text-gray-300">
                                                        <input type="checkbox" checked={excludedValues.has(value)} onChange={() => handleCheck(value, true)} className="mr-2 h-4 w-4 text-red-600 border-gray-300 rounded focus:ring-red-500 dark:bg-gray-600 dark:border-gray-500"/>
                                                        <span className="truncate">{value}</span>
                                                    </label>
                                                ))}
                                            </div>
                                        </div>
                                    </div>
                                </>
                            )}
                        </div>

                        <div className="mt-4 flex justify-between items-center">
                            <button onClick={handleRemoveFilter} className="px-4 py-2 text-sm text-red-600 hover:text-red-800">Remove Filter</button>
                            <div className="space-x-2">
                                <button onClick={onClose} className="px-4 py-2 bg-gray-200 dark:bg-gray-600 dark:text-white rounded-md text-sm">Cancel</button>
                                <button onClick={handleApply} className="px-4 py-2 bg-cyan-600 text-white rounded-md text-sm">OK</button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }
        
        function ReportsSidebar({ fields, setFields, savedReports, onLoadReport, onSaveReportClick, onUpdateReport, onDeleteReport, isAdmin }) {
            const [openSections, setOpenSections] = useState({ reports: true, fields: true });
            const [reportToEdit, setReportToEdit] = useState(null);
            const [deleteModal, setDeleteModal] = useState(null);
            
            const toggleSection = (section) => setOpenSections(prev => ({...prev, [section]: !prev[section]}));

            const handleFieldToggle = (key) => {
                setFields(prev => prev.map(c => c.key === key ? { ...c, visible: !c.visible } : c));
            };
            
            const handleSave = (name, isWidget, isShared, targetMin, targetMax, targetType, reverseRange) => {
                const updatedReport = {
                    ...reportToEdit,
                    name: name.trim(),
                    isWidget,
                    isShared,
                    targetMin: parseInt(targetMin, 10) || null,
                    targetMax: parseInt(targetMax, 10) || null,
                    targetType,
                    reverseRange: isWidget ? reverseRange : false
                };
                onUpdateReport(updatedReport);
                setReportToEdit(null);
            };

            const handleDelete = () => {
                if (deleteModal) {
                    onDeleteReport(deleteModal.id, deleteModal.isPersonal);
                }
                setDeleteModal(null);
            };

            return (
                <>
                <div className="w-80 bg-white dark:bg-gray-900 border-r border-gray-200 dark:border-gray-700 flex flex-col p-4 space-y-2 overflow-y-auto">
                    <h2 className="text-xl font-bold dark:text-gray-200">Report Controls</h2>
                    <div className="space-y-2">
                        <button onClick={onSaveReportClick} className="w-full px-4 py-2 bg-cyan-600 text-white rounded-md shadow-sm hover:bg-cyan-700">Save New Report</button>
                    </div>
                    
                    <SidebarSection title="Saved Reports" id="reports" isOpen={openSections.reports} onToggle={toggleSection}>
                        <div className="max-h-60 overflow-y-auto">
                            {savedReports.map((r) => (
                                <div key={r.id} className="flex items-center justify-between text-sm group pr-1">
                                    <button onClick={() => onLoadReport(r)} className="hover:underline text-left flex-grow truncate py-1 dark:text-gray-300">
                                        {r.name}
                                        <span className="text-gray-400 ml-1">{r.isPersonal ? '(Personal)' : '(Shared)'}</span>
                                    </button>
                                    <div className="hidden group-hover:flex items-center flex-shrink-0">
                                        <button onClick={() => setReportToEdit(r)} className="p-1 hover:bg-gray-200 dark:hover:bg-gray-700 rounded text-xs"></button>
                                        <button onClick={() => setDeleteModal(r)} className="p-1 hover:bg-gray-200 dark:hover:bg-gray-700 rounded text-xs"></button>
                                    </div>
                                </div>
                            ))}
                            {savedReports.length === 0 && <p className="text-sm text-gray-400">No saved reports.</p>}
                        </div>
                    </SidebarSection>

                    <SidebarSection title="Fields" id="fields" isOpen={openSections.fields} onToggle={toggleSection}>
                        <div className="mt-2 space-y-1 max-h-60 overflow-y-auto">
                           {fields.map(field => (
                                <label key={field.key} className="flex items-center text-sm p-1 hover:bg-gray-50 dark:hover:bg-gray-700 rounded dark:text-gray-300">
                                    <input type="checkbox" checked={field.visible} onChange={() => handleFieldToggle(field.key)} className="mr-2 h-4 w-4 text-cyan-600 border-gray-300 rounded focus:ring-cyan-500 dark:bg-gray-600 dark:border-gray-500"/>
                                    <span className={field.isCustom ? 'italic' : ''}>{field.label}</span>
                                </label>
                            ))}
                        </div>
                    </SidebarSection>
                </div>
                {reportToEdit && <SaveReportModal reportToEdit={reportToEdit} onSave={handleSave} onCancel={() => setReportToEdit(null)} isAdmin={isAdmin} />}
                {deleteModal && <DeleteModal report={deleteModal} onDelete={handleDelete} onCancel={() => setDeleteModal(null)} />}
                </>
            );
        }

        function SaveReportModal({ onSave, onCancel, reportToEdit, isAdmin }) {
            const [name, setName] = useState(reportToEdit?.name || '');
            const [isShared, setIsShared] = useState(reportToEdit?.isShared || false);
            const [isWidget, setIsWidget] = useState(reportToEdit?.isWidget || false);
            const [targetMin, setTargetMin] = useState(reportToEdit?.targetMin || '');
            const [targetMax, setTargetMax] = useState(reportToEdit?.targetMax || '');
            const [targetType, setTargetType] = useState(reportToEdit?.targetType || 'count');
            const [reverseRange, setReverseRange] = useState(reportToEdit?.reverseRange || false);

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-40">
                    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm">
                        <h3 className="font-bold text-lg dark:text-gray-200">{reportToEdit?.id ? 'Edit Report' : 'Save Report'}</h3>
                        <p className="text-sm text-gray-500 dark:text-gray-400 mt-2">Enter a name for this report configuration.</p>
                        <input 
                            type="text" 
                            value={name} 
                            onChange={(e) => setName(e.target.value)} 
                            className="w-full mt-4 px-3 py-2 border rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white" 
                            placeholder="Report Name" 
                        />
                         {isWidget && (
                            <div className="mt-4">
                                <div className="flex items-center justify-between mb-2">
                                    <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Target Range</label>
                                    <select value={targetType} onChange={e => setTargetType(e.target.value)} className="text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white rounded-md">
                                        <option value="count">Count</option>
                                        <option value="percentage">Percentage</option>
                                    </select>
                                </div>
                                <div className="grid grid-cols-2 gap-4">
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Min</label>
                                        <input 
                                            type="number" 
                                            value={targetMin} 
                                            onChange={(e) => setTargetMin(e.target.value)} 
                                            className="w-full mt-1 px-3 py-2 border rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white" 
                                            placeholder={targetType === 'count' ? "e.g., 65" : "e.g., 10"}
                                        />
                                    </div>
                                    <div>
                                        <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Max</label>
                                        <input 
                                            type="number" 
                                            value={targetMax} 
                                            onChange={(e) => setTargetMax(e.target.value)} 
                                            className="w-full mt-1 px-3 py-2 border rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white" 
                                            placeholder={targetType === 'count' ? "e.g., 75" : "e.g., 15"}
                                        />
                                    </div>
                                </div>
                                <label className="flex items-center mt-2 text-sm dark:text-gray-300">
                                    <input type="checkbox" checked={reverseRange} onChange={e => setReverseRange(e.target.checked)} className="mr-2"/>
                                    Reverse Target Colors (Lower is better)
                                </label>
                            </div>
                        )}
                        <label className="flex items-center mt-4 text-sm dark:text-gray-300">
                            <input type="checkbox" checked={isWidget} onChange={e => setIsWidget(e.target.checked)} className="mr-2"/>
                            Add as a Dashboard Widget
                        </label>
                        {isAdmin && (
                            <label className="flex items-center mt-2 text-sm dark:text-gray-300">
                                <input type="checkbox" checked={isShared} onChange={(e) => setIsShared(e.target.checked)} className="mr-2"/>
                                Share with organization
                            </label>
                        )}
                        <div className="mt-6 flex justify-end space-x-2">
                            <button onClick={onCancel} className="px-4 py-2 bg-gray-200 dark:bg-gray-600 dark:text-white rounded-md">Cancel</button>
                            <button onClick={() => onSave(name, isWidget, isShared, targetMin, targetMax, targetType, reverseRange)} className="px-4 py-2 bg-cyan-600 text-white rounded-md text-sm">OK</button>
                        </div>
                    </div>
                </div>
            );
        }

        function DeleteModal({ report, onDelete, onCancel }) {
            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-40">
                    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-sm">
                        <h3 className="font-bold text-lg dark:text-gray-200">Delete Report</h3>
                        <p className="text-sm text-gray-500 dark:text-gray-400 mt-2">Are you sure you want to delete the report "{report.name}"? This action cannot be undone.</p>
                        <div className="mt-6 flex justify-end space-x-2">
                            <button onClick={onCancel} className="px-4 py-2 bg-gray-200 dark:bg-gray-600 dark:text-white rounded-md">Cancel</button>
                            <button onClick={onDelete} className="px-4 py-2 bg-red-600 text-white rounded-md">Delete</button>
                        </div>
                    </div>
                </div>
            );
        }
        
        function AdminPage({ allUsers, cheatSheetContent, onBack }) {
            const [searchTerm, setSearchTerm] = useState('');
            const [calendarIdInput, setCalendarIdInput] = useState('');
            const [cheatSheetInput, setCheatSheetInput] = useState(cheatSheetContent);
            
            useEffect(() => {
                const settingsDocRef = db.collection('public').doc('settings');
                settingsDocRef.get().then(doc => {
                    if (doc.exists) {
                        setCalendarIdInput(doc.data().googleCalendarId || '');
                    }
                });
            }, []);

            const handleSaveCheatSheet = async () => {
                const cheatSheetDocRef = db.collection('public').doc('cheatSheet');
                try {
                    await cheatSheetDocRef.set({ content: cheatSheetInput });
                    alert('Cheat Sheet saved successfully!');
                } catch (error) {
                    console.error("Error saving Cheat Sheet:", error);
                    alert('Failed to save Cheat Sheet.');
                }
            };
            
            const filteredUsers = useMemo(() => {
                const lowercasedTerm = searchTerm.toLowerCase();
                if (!lowercasedTerm) return allUsers;
                return allUsers.filter(user => 
                    (user.email && user.email.toLowerCase().includes(lowercasedTerm)) ||
                    (user.id && user.id.toLowerCase().includes(lowercasedTerm))
                );
            }, [searchTerm, allUsers]);

            const handleDeleteUser = (userId) => {
                alert(`The user deletion for ${userId} would be handled by a secure backend function.`);
            };

            const handleSaveCalendarId = async () => {
                const settingsDocRef = db.collection('public').doc('settings');
                try {
                    await settingsDocRef.set({ googleCalendarId: calendarIdInput }, { merge: true });
                    alert('Google Calendar ID saved successfully!');
                } catch (error) {
                    console.error("Error saving calendar ID:", error);
                    alert('Failed to save calendar ID.');
                }
            };

            return (
                <div className="p-8">
                    <button onClick={onBack} className="mb-6 text-cyan-600 dark:text-cyan-400 hover:text-cyan-800 dark:hover:text-cyan-200"> &larr; Back to Dashboard</button>
                    <h2 className="text-4xl font-bold text-gray-800 dark:text-gray-200">Admin Panel</h2>
                    <p className="text-gray-500 dark:text-gray-400 mt-2">Manage user accounts and data.</p>
                    
                    <div className="mt-8 bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                        <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200">Settings</h3>
                        <div className="mt-4">
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Public Google Calendar ID</label>
                            <div className="flex items-center space-x-2 mt-1">
                                <input 
                                    type="text" 
                                    value={calendarIdInput} 
                                    onChange={e => setCalendarIdInput(e.target.value)} 
                                    placeholder="your-calendar-id@group.calendar.google.com" 
                                    className="flex-grow w-full px-3 py-2 border rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                                />
                                <button onClick={handleSaveCalendarId} className="px-4 py-2 bg-cyan-600 text-white rounded-md hover:bg-cyan-700">Save</button>
                            </div>
                        </div>
                        <div className="mt-4">
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Cheat Sheet Content</label>
                            <div className="flex items-center space-x-2 mt-1">
                                <textarea
                                    value={cheatSheetInput}
                                    onChange={e => setCheatSheetInput(e.target.value)}
                                    placeholder="Enter cheat sheet content here..."
                                    className="flex-grow w-full h-40 px-3 py-2 border rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                                />
                            </div>
                            <button onClick={handleSaveCheatSheet} className="mt-2 px-4 py-2 bg-cyan-600 text-white rounded-md hover:bg-cyan-700">Save Cheat Sheet</button>
                        </div>
                    </div>

                     <div className="mt-8 bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                        <h3 className="text-xl font-semibold text-gray-800 dark:text-gray-200">Version Information</h3>
                        <div className="mt-4 text-sm text-gray-600 dark:text-gray-400">
                            <p><span className="font-semibold">Version:</span> {CRM_VERSION}</p>
                            <p><span className="font-semibold">Last Update:</span> {CRM_VERSION_DESCRIPTION}</p>
                        </div>
                    </div>

                    <div className="mt-8">
                        <input type="text" value={searchTerm} onChange={e => setSearchTerm(e.target.value)} placeholder="Filter users by email or ID..." className="w-full max-w-lg px-4 py-2 border rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"/>
                    </div>
                    
                    <div className="mt-8 bg-white dark:bg-gray-800 rounded-lg shadow overflow-hidden">
                        <ul className="divide-y divide-gray-200 dark:divide-gray-700">
                            {filteredUsers.map(user => (
                                <li key={user.id} className="w-full p-4 hover:bg-gray-50 dark:hover:bg-gray-700 flex justify-between items-center">
                                    <div>
                                        <p className="font-semibold text-gray-800 dark:text-gray-200">{user.email || 'No Email'}</p>
                                        <p className="text-sm text-gray-500 dark:text-gray-400">UID: {user.id}</p>
                                        <p className="text-sm text-gray-500 dark:text-gray-400">Admin: {user.isAdmin ? 'Yes' : 'No'}</p>
                                    </div>
                                    <button onClick={() => handleDeleteUser(user.id)} className="px-4 py-2 bg-red-600 text-white rounded-md text-sm hover:bg-red-700">
                                        Delete User
                                    </button>
                                </li>
                            ))}
                        </ul>
                    </div>
                </div>
            );
        }

        function ChecklistPage({ checklist, onAdd, onUpdate, onDelete, onBack, isAdmin, onSelectCustomer }) {
            const [newItemText, setNewItemText] = useState('');
            
            const handleAddItem = (e) => {
                e.preventDefault();
                onAdd(newItemText);
                setNewItemText('');
            };

            const categorizedChecklist = useMemo(() => {
                const today = new Date();
                today.setHours(0, 0, 0, 0);
                const tomorrow = new Date(today);
                tomorrow.setDate(tomorrow.getDate() + 1);

                const categories = {
                    overdue: [],
                    dueToday: [],
                    notYetDue: [],
                };

                const sortItems = (items) => {
                    return items.sort((a, b) => {
                        const dateA = a.dueDate ? new Date(a.dueDate) : new Date(0);
                        const dateB = b.dueDate ? new Date(b.dueDate) : new Date(0);
                        return dateA - dateB;
                    });
                }

                if (isAdmin) {
                    const adminCategories = {};
                    checklist.forEach(userList => {
                        const userCats = { overdue: [], dueToday: [], notYetDue: [] };
                        userList.items.forEach(item => {
                            if (!item.dueDate) {
                                userCats.dueToday.push(item);
                            } else {
                                const dueDate = new Date(item.dueDate);
                                if (dueDate < today) userCats.overdue.push(item);
                                else if (dueDate < tomorrow) userCats.dueToday.push(item);
                                else userCats.notYetDue.push(item);
                            }
                        });
                        adminCategories[userList.userId] = {
                            ...userList,
                            items: {
                                overdue: sortItems(userCats.overdue),
                                dueToday: sortItems(userCats.dueToday),
                                notYetDue: sortItems(userCats.notYetDue),
                            }
                        };
                    });
                    return adminCategories;
                } else {
                    checklist.forEach(item => {
                        if (!item.dueDate) {
                            categories.dueToday.push(item);
                        } else {
                            const dueDate = new Date(item.dueDate);
                            if (dueDate < today) categories.overdue.push(item);
                            else if (dueDate < tomorrow) categories.dueToday.push(item);
                            else categories.notYetDue.push(item);
                        }
                    });
                    return {
                        overdue: sortItems(categories.overdue),
                        dueToday: sortItems(categories.dueToday),
                        notYetDue: sortItems(categories.notYetDue),
                    };
                }
            }, [checklist, isAdmin]);

            const renderTaskText = (item) => {
                const text = item.text || '';
                if (text.includes('@@')) {
                    const [customerId, rest] = text.split('@@');
                    const [customerName, ...taskDescriptionParts] = rest.split(/:(.*)/s);
                    const taskDescription = taskDescriptionParts.join(':');

                    return (
                        <>
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onSelectCustomer({ id: customerId, given_name: customerName.split(' ')[0] });
                                }}
                                className="text-cyan-600 dark:text-cyan-400 hover:underline font-medium"
                            >
                                {customerName}:
                            </button>
                            <span className="ml-1">{taskDescription}</span>
                        </>
                    );
                }
                return text;
            };

            const renderDueDate = (item) => {
                if (!item.dueDate) return null;
                const today = new Date();
                today.setHours(0, 0, 0, 0); // Set to start of day for accurate comparison
                const dueDate = new Date(item.dueDate);
                 // Adjust for timezone offset
                const userTimezoneOffset = dueDate.getTimezoneOffset() * 60000;
                const adjustedDueDate = new Date(dueDate.getTime() + userTimezoneOffset);
                const isOverdue = adjustedDueDate < today && !item.completed;

                return (
                    <span className={`text-sm ml-auto mr-2 ${isOverdue ? 'text-red-500 font-semibold' : 'text-gray-500 dark:text-gray-400'}`}>
                        Due: {formatSimpleDate(item.dueDate)}
                    </span>
                );
            };

            const renderTaskList = (items, userId) => (
                <ul className="space-y-4">
                    {items.map(item => (
                        <li key={item.id} className="flex items-center space-x-3 group">
                            <input 
                                type="checkbox" 
                                checked={item.completed} 
                                onChange={(e) => onUpdate(userId, item.id, e.target.checked)}
                                className="h-5 w-5 text-cyan-600 border-gray-300 rounded focus:ring-cyan-500 dark:bg-gray-600 dark:border-gray-500"
                            />
                            <span className={`flex-grow dark:text-gray-200 ${item.completed ? 'line-through text-gray-400 dark:text-gray-500' : ''}`}>
                                {renderTaskText(item)}
                            </span>
                            {renderDueDate(item)}
                            <button onClick={() => onDelete(userId, item.id)} className="text-red-500 hover:text-red-700 opacity-0 group-hover:opacity-100 transition-opacity">
                                <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clipRule="evenodd" /></svg>
                            </button>
                        </li>
                    ))}
                </ul>
            );
            
             const renderCategory = (title, items, userId) => {
                if (items.length === 0) return null;
                return (
                    <div>
                        <h4 className="text-md font-semibold text-gray-500 dark:text-gray-400 mb-2">{title}</h4>
                        {renderTaskList(items, userId)}
                    </div>
                );
            };

            return (
                <div className="p-8">
                    <button onClick={onBack} className="mb-6 text-cyan-600 dark:text-cyan-400 hover:text-cyan-800 dark:hover:text-cyan-200"> &larr; Back to Dashboard</button>
                    <h2 className="text-4xl font-bold text-gray-800 dark:text-gray-200">{isAdmin ? 'All Checklists' : 'My Checklist'}</h2>
                    <p className="text-gray-500 dark:text-gray-400 mt-2">{isAdmin ? 'View and manage all user checklists.' : 'Personal tasks and reminders.'}</p>
                    
                    <div className="mt-8 bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                         <form onSubmit={handleAddItem} className="flex space-x-2 mb-6">
                            <input 
                                type="text"
                                value={newItemText}
                                onChange={(e) => setNewItemText(e.target.value)}
                                placeholder="Add a new item..."
                                className="flex-grow px-4 py-2 border rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                            />
                            <button type="submit" className="px-4 py-2 bg-cyan-600 text-white rounded-md hover:bg-cyan-700">Add</button>
                        </form>
                        
                        {isAdmin ? (
                            <div className="space-y-6">
                                {Object.values(categorizedChecklist).length === 0 && <p className="text-gray-500 text-center dark:text-gray-400">No checklists found.</p>}
                                {Object.values(categorizedChecklist).map(userList => (
                                    <div key={userList.userId}>
                                        <h3 className="text-lg font-semibold text-gray-700 dark:text-gray-300 border-b border-gray-200 dark:border-gray-700 pb-2 mb-3">
                                            {userList.userIdentifier}
                                        </h3>
                                        <div className="space-y-4">
                                            {renderCategory("Overdue", userList.items.overdue, userList.userId)}
                                            {renderCategory("Due Today", userList.items.dueToday, userList.userId)}
                                            {renderCategory("Not Yet Due", userList.items.notYetDue, userList.userId)}
                                        </div>
                                    </div>
                                ))}
                            </div>
                        ) : (
                            <div className="space-y-4">
                                {renderCategory("Overdue", categorizedChecklist.overdue, user.uid)}
                                {renderCategory("Due Today", categorizedChecklist.dueToday, user.uid)}
                                {renderCategory("Not Yet Due", categorizedChecklist.notYetDue, user.uid)}
                                {categorizedChecklist.overdue.length === 0 && categorizedChecklist.dueToday.length === 0 && categorizedChecklist.notYetDue.length === 0 &&
                                    <p className="text-gray-500 text-center dark:text-gray-400">No items on your checklist.</p>
                                }
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        function CheatSheetModal({ content, onClose }) {
             useEffect(() => {
                document.body.style.overflow = 'hidden';
                return () => {
                    document.body.style.overflow = 'unset';
                };
            }, []);

            return (
                 <div className="fixed inset-0 bg-black bg-opacity-50 flex items-start justify-center z-40 overflow-y-auto p-4 pt-16">
                    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-4xl max-h-full" onClick={e => e.stopPropagation()}>
                         <div className="p-8">
                            <div className="flex justify-between items-center">
                                <h2 className="text-3xl font-bold text-gray-800 dark:text-gray-200">Cheat Sheet</h2>
                                <button onClick={onClose} className="text-gray-400 hover:text-gray-600 dark:hover:text-white text-3xl">&times;</button>
                            </div>
                            <div className="mt-6 p-4 bg-gray-50 dark:bg-gray-700 rounded-md max-h-96 overflow-y-auto">
                                <p className="text-gray-800 dark:text-gray-300 whitespace-pre-wrap">{content || 'No content has been set for the cheat sheet yet.'}</p>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        function CustomerProfileModal({ customer, isLoading, onClose, groupsMap, segmentsMap, onLogContact, onSaveContact, customAttrDefs, onEditNoteRequest, onCreateTaskRequest, onUpdateTask, onDeleteTask }) {
            useEffect(() => {
                document.body.style.overflow = 'hidden';
                return () => {
                    document.body.style.overflow = 'unset';
                };
            }, []);

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-start justify-center z-40 overflow-y-auto p-4 pt-16">
                    <div className="bg-gray-100 dark:bg-gray-900 rounded-lg shadow-xl w-full max-w-4xl max-h-full" onClick={e => e.stopPropagation()}>
                        {isLoading && !customer.orders ? (
                            <div className="flex justify-center items-center h-64">
                                <div className="spinner"></div>
                                <p className="ml-2 dark:text-gray-300">Fetching Details...</p>
                            </div>
                        ) : (
                            <CustomerProfile 
                                customer={customer} 
                                groupsMap={groupsMap} 
                                segmentsMap={segmentsMap} 
                                onBack={onClose}
                                onLogContact={onLogContact}
                                onSaveContact={onSaveContact}
                                customAttrDefs={customAttrDefs}
                                onEditNoteRequest={onEditNoteRequest}
                                onCreateTaskRequest={onCreateTaskRequest}
                                onUpdateTask={onUpdateTask}
                                onDeleteTask={onDeleteTask}
                            />
                        )}
                    </div>
                </div>
            );
        }

        function CustomerProfile({ customer, groupsMap, segmentsMap, onBack, onLogContact, onSaveContact, customAttrDefs, onEditNoteRequest, onCreateTaskRequest, onUpdateTask, onDeleteTask }) {
            
            const formatAddress = (address) => {
                if (!address) return 'N/A';
                const parts = [ address.address_line_1, address.address_line_2, `${address.locality || ''} ${address.administrative_district_level_1 || ''} ${address.postal_code || ''}`.trim(), address.country ];
                return parts.filter(Boolean).join(', ');
            };

            const formatCustomAttributeLabel = (label) => {
                if (/^[A-Z]:\s/.test(label)) {
                    return label.substring(3);
                }
                return label;
            };
            
            const lastSmsContact = customer.last_sms_contact;

            const {
                pronouns,
                instagram,
                legalName,
                booleanAttributes,
                otherAttributes
            } = useMemo(() => {
                const booleanAttributes = { true: [], false: [] };
                const otherAttributes = [];
                let pronouns = getNestedValue(customer, ['custom_attributes', PRONOUNS_ATTR_KEY, 'value']);
                let instagram = getNestedValue(customer, ['custom_attributes', INSTAGRAM_ATTR_KEY, 'value']);
                let legalName = getNestedValue(customer, ['custom_attributes', LEGAL_NAME_ATTR_KEY, 'value']);

                Array.from(customer.custom_attributes ? Object.values(customer.custom_attributes) : []).forEach(attr => {
                    const def = customAttrDefs.get(attr.key);
                    if (!def || attr.key === PRONOUNS_ATTR_KEY || attr.key === INSTAGRAM_ATTR_KEY || attr.key === LEGAL_NAME_ATTR_KEY) return;
                    
                    const formattedName = formatCustomAttributeLabel(def.name);

                    if (def.schema.$ref.includes('Boolean')) {
                        if (attr.value === true) booleanAttributes.true.push(formattedName);
                        else booleanAttributes.false.push(formattedName);
                    } else {
                        otherAttributes.push({ label: formattedName, value: attr.value });
                    }
                });
                return { pronouns, instagram, legalName, booleanAttributes, otherAttributes };
            }, [customer.custom_attributes, customAttrDefs]);
            
            const renderDueDate = (item) => {
                if (!item.dueDate) return null;
                const today = new Date();
                today.setHours(0, 0, 0, 0); // Set to start of day for accurate comparison
                const dueDate = new Date(item.dueDate);
                 // Adjust for timezone offset
                const userTimezoneOffset = dueDate.getTimezoneOffset() * 60000;
                const adjustedDueDate = new Date(dueDate.getTime() + userTimezoneOffset);
                const isOverdue = adjustedDueDate < today && !item.completed;

                return (
                    <span className={`text-sm ml-auto mr-2 ${isOverdue ? 'text-red-500 font-semibold' : 'text-gray-500 dark:text-gray-400'}`}>
                        Due: {formatSimpleDate(item.dueDate)}
                    </span>
                );
            };

            return (
                <div className="p-8">
                    <button onClick={onBack} className="mb-6 text-cyan-600 dark:text-cyan-400 hover:text-cyan-800 dark:hover:text-cyan-200"> &larr; Back</button>
                    <div className="bg-white dark:bg-gray-800 p-8 rounded-lg shadow-md">
                        <h2 className="text-4xl font-bold text-gray-800 dark:text-gray-200">{customer.given_name} {customer.family_name}</h2>
                        <p className="text-gray-500 dark:text-gray-400">Customer since {formatSimpleDate(customer.created_at)}</p>
                        
                        <div className="mt-8 grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8">
                            <InfoCard title="Contact Information">
                                <InfoItem label="Email" value={customer.email_address} />
                                <InfoItem label="Phone" value={customer.phone_number} />
                                <InfoItem label="Pronouns" value={pronouns} />
                                <InfoItem label="Instagram" value={instagram ? `@${instagram.replace('@', '')}` : null} />
                                <button onClick={() => onSaveContact(customer)} className="mt-2 w-full px-4 py-2 bg-green-600 text-white rounded-md shadow-sm hover:bg-green-700">Save Contact</button>
                            </InfoCard>
                            <InfoCard title="Stats">
                                <InfoItem label="Last Visit" value={customer.last_visit ? formatDetailedDate(customer.last_visit) : 'No visits found'} />
                                <InfoItem label="Last SMS Contact" value={lastSmsContact ? formatSimpleDate(lastSmsContact) : 'N/A'} />
                                <div className="flex space-x-2 mt-2">
                                    <button onClick={() => onLogContact(customer.id)} className="w-full px-4 py-2 bg-cyan-600 text-white rounded-md shadow-sm hover:bg-cyan-700">Log Contact</button>
                                    <button onClick={() => onCreateTaskRequest(customer)} className="w-full px-4 py-2 bg-blue-600 text-white rounded-md shadow-sm hover:bg-blue-700">Create Task</button>
                                </div>
                            </InfoCard>
                            <InfoCard title="Details">
                                <InfoItem label="Legal Name" value={legalName} />
                                <InfoItem label="Birthday" value={customer.birthday ? formatSimpleDate(customer.birthday) : 'N/A'} />
                                <InfoItem label="Company" value={customer.company_name} />
                                <InfoItem label="Reference ID" value={customer.reference_id} />
                                <InfoItem label="Address" value={formatAddress(customer.address)} />
                            </InfoCard>
                            <InfoCard title="Associated Tasks" className="md:col-span-3">
                                {customer.associatedTasks && customer.associatedTasks.length > 0 ? (
                                    <ul className="space-y-2">
                                        {customer.associatedTasks.map(task => (
                                            <li key={task.id} className="flex items-center space-x-3 group">
                                                 <input 
                                                    type="checkbox" 
                                                    checked={task.completed} 
                                                    onChange={(e) => onUpdateTask(task.userId, task.id, e.target.checked)}
                                                    className="h-5 w-5 text-cyan-600 border-gray-300 rounded focus:ring-cyan-500 dark:bg-gray-600 dark:border-gray-500"
                                                />
                                                <span className={`flex-grow dark:text-gray-200 ${task.completed ? 'line-through text-gray-400 dark:text-gray-500' : ''}`}>
                                                    {task.text.split('@@')[1].split(/:(.*)/s)[1]}
                                                </span>
                                                {renderDueDate(task)}
                                                <button onClick={() => onDeleteTask(task.userId, task.id)} className="text-red-500 hover:text-red-700 opacity-0 group-hover:opacity-100 transition-opacity">
                                                    <svg xmlns="http://www.w3.org/2000/svg" className="h-5 w-5" viewBox="0 0 20 20" fill="currentColor"><path fillRule="evenodd" d="M9 2a1 1 0 00-.894.553L7.382 4H4a1 1 0 000 2v10a2 2 0 002 2h8a2 2 0 002-2V6a1 1 0 100-2h-3.382l-.724-1.447A1 1 0 0011 2H9zM7 8a1 1 0 012 0v6a1 1 0 11-2 0V8zm6 0a1 1 0 012 0v6a1 1 0 11-2 0V8z" clipRule="evenodd" /></svg>
                                                </button>
                                            </li>
                                        ))}
                                    </ul>
                                ) : (
                                    <p className="text-gray-500 dark:text-gray-400">No tasks associated with this customer.</p>
                                )}
                            </InfoCard>
                            <InfoCard title="Notes" className="md:col-span-3">
                                <p className="text-gray-800 dark:text-gray-300 whitespace-pre-wrap">{customer.note || 'N/A'}</p>
                                <button onClick={() => onEditNoteRequest(customer)} className="mt-2 px-3 py-1 bg-gray-200 dark:bg-gray-700 text-sm rounded-md hover:bg-gray-300 dark:hover:bg-gray-600">Edit</button>
                            </InfoCard>
                            <InfoCard title="Custom Fields" className="md:col-span-3">
                                <div className="grid grid-cols-2 gap-x-8">
                                    <div>
                                        <h4 className="font-semibold text-gray-600 dark:text-gray-400 border-b dark:border-gray-700 pb-1 mb-2">True</h4>
                                        <ul className="space-y-1 dark:text-gray-300">
                                            {booleanAttributes.true.length > 0 ? booleanAttributes.true.map(name => <li key={name}>{name}</li>) : <li className="text-gray-400">None</li>}
                                        </ul>
                                    </div>
                                    <div>
                                        <h4 className="font-semibold text-gray-600 dark:text-gray-400 border-b dark:border-gray-700 pb-1 mb-2">False</h4>
                                        <ul className="space-y-1 dark:text-gray-300">
                                            {booleanAttributes.false.length > 0 ? booleanAttributes.false.map(name => <li key={name}>{name}</li>) : <li className="text-gray-400">None</li>}
                                        </ul>
                                    </div>
                                </div>
                                {otherAttributes.length > 0 && (
                                    <div className="mt-4 pt-4 border-t dark:border-gray-700">
                                        {otherAttributes.map(attr => <InfoItem key={attr.label} label={attr.label} value={attr.value} />)}
                                    </div>
                                )}
                            </InfoCard>
                            <InfoCard title="Order History" className="md:col-span-3">
                                <div className="max-h-60 overflow-y-auto">
                                    {customer.orders && customer.orders.length > 0 ? (
                                        <table className="w-full text-sm text-left">
                                            <thead>
                                                <tr className="bg-gray-50 dark:bg-gray-700">
                                                    <th className="p-2">Line Item</th>
                                                    <th className="p-2">Qty</th>
                                                    <th className="p-2">Date</th>
                                                </tr>
                                            </thead>
                                            <tbody>
                                                {customer.orders.flatMap((order) => 
                                                    (order.line_items || []).map((item) => (
                                                        <tr key={`${order.id}-${item.uid}`} className="border-b dark:border-gray-700">
                                                            <td className="p-2">{item.name}</td>
                                                            <td className="p-2">{item.quantity}</td>
                                                            <td className="p-2">{formatSimpleDate(order.closed_at)}</td>
                                                        </tr>
                                                    ))
                                                )}
                                            </tbody>
                                        </table>
                                    ) : (
                                        <p className="text-gray-500 dark:text-gray-400">No orders found for this customer.</p>
                                    )}
                                </div>
                            </InfoCard>
                             <InfoCard title="Groups & Segments" className="md:col-span-3">
                                <div className="flex flex-wrap gap-2">
                                    {(customer.group_ids || []).map(id => <Pill key={id} text={groupsMap.get(id) || id} />)}
                                    {(customer.segment_ids || []).map(id => <Pill key={id} text={segmentsMap.get(id) || id} color="bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-300" />)}
                                </div>
                            </InfoCard>
                        </div>
                    </div>
                </div>
            );
        }
        
        const InfoCard = ({ title, children, className }) => (<div className={`bg-white dark:bg-gray-800 p-6 rounded-lg shadow-sm border dark:border-gray-700 ${className || ''}`}><h3 className="text-lg font-semibold text-gray-800 dark:text-gray-200 border-b dark:border-gray-700 pb-2 mb-4">{title}</h3><div className="space-y-3">{children}</div></div>);
        const InfoItem = ({ label, value }) => (<div><p className="text-sm text-gray-500 dark:text-gray-400">{label}</p><p className="font-medium text-gray-800 dark:text-gray-200">{value || 'N/A'}</p></div>);
        const Pill = ({ text, color = 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300' }) => (<span className={`px-3 py-1 text-sm font-medium rounded-full ${color}`}>{text}</span>);
        const SidebarSection = ({ title, id, children, isOpen, onToggle }) => (
            <div className="dark:text-gray-300">
                <button onClick={() => onToggle(id)} className="font-semibold w-full text-left flex justify-between items-center py-2">
                    {title}
                    <span className="transform transition-transform">{isOpen ? '' : '+'}</span>
                </button>
                {isOpen && <div className="mt-2 space-y-2 pl-2 border-l-2 border-gray-200 dark:border-gray-700">{children}</div>}
            </div>
        );

        function TaskCreatorModal({ customer, onSave, onCancel }) {
            const [taskText, setTaskText] = useState('');
            const [dueDate, setDueDate] = useState('');
            const customerName = `${customer.given_name} ${customer.family_name}`;

            const handleSave = () => {
                const fullTaskText = `${customer.id}@@${customerName}: ${taskText}`;
                onSave(fullTaskText, dueDate);
                onCancel();
            };

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
                    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg">
                        <h3 className="font-bold text-lg dark:text-gray-200">Create Task for {customerName}</h3>
                        <textarea
                            value={taskText}
                            onChange={(e) => setTaskText(e.target.value)}
                            className="w-full h-32 mt-4 p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                            placeholder="e.g., about the singles night event..."
                        />
                        <div className="mt-4">
                            <label className="block text-sm font-medium text-gray-700 dark:text-gray-300">Due Date (Optional)</label>
                            <input
                                type="date"
                                value={dueDate}
                                onChange={(e) => setDueDate(e.target.value)}
                                className="w-full mt-1 px-3 py-2 border rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                            />
                        </div>
                        <div className="flex justify-end space-x-2 mt-4">
                            <button onClick={onCancel} className="px-4 py-2 bg-gray-200 dark:bg-gray-600 rounded-md">Cancel</button>
                            <button onClick={handleSave} className="px-4 py-2 bg-cyan-600 text-white rounded-md">Save Task</button>
                        </div>
                    </div>
                </div>
            );
        }

        function NoteEditorModal({ customer, onSave, onCancel }) {
            const [noteText, setNoteText] = useState(customer.note || '');

            useEffect(() => {
                setNoteText(customer.note || '');
            }, [customer]);

            const handleSave = () => {
                onSave(customer.id, noteText);
            };

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-40">
                    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-xl p-6 w-full max-w-lg">
                        <h3 className="font-bold text-lg dark:text-gray-200">Edit Note for {customer.given_name} {customer.family_name}</h3>
                        <textarea
                            value={noteText}
                            onChange={(e) => setNoteText(e.target.value)}
                            className="w-full h-40 mt-4 p-2 border rounded-md dark:bg-gray-700 dark:border-gray-600 dark:text-white"
                            placeholder="Enter notes here..."
                        />
                        <div className="flex justify-end space-x-2 mt-4">
                            <button onClick={onCancel} className="px-4 py-2 bg-gray-200 dark:bg-gray-600 rounded-md">Cancel</button>
                            <button onClick={handleSave} className="px-4 py-2 bg-cyan-600 text-white rounded-md">Save Note</button>
                        </div>
                    </div>
                </div>
            );
        }

        const container = document.getElementById('root');
        const root = ReactDOM.createRoot(container);
        root.render(<App />);
    </script>
</body>
</html>

